

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>2.3. 聚类 &#8212; scikit-learn 0.19.0 中文文档 - ApacheCN</title>
<!-- htmltitle is before nature.css - we use this hack to load bootstrap first -->
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="../_static/css/bootstrap.min.css" media="screen" />
<link rel="stylesheet" href="../_static/css/bootstrap-responsive.css"/>

    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="2.4. 双聚类" href="biclustering.html" />
    <link rel="prev" title="2.2. 流形学习" href="manifold.html" />


<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<script src="../_static/js/bootstrap.min.js" type="text/javascript"></script>
<link rel="canonical" href="http://scikit-learn.org/stable/modules/clustering.html" />

<script type="text/javascript">
  $("div.buttonNext, div.buttonPrevious").hover(
     function () {
         $(this).css('background-color', '#FF9C34');
     },
     function () {
         $(this).css('background-color', '#A7D6E2');
     }
  );
  function showMenu() {
    var topNav = document.getElementById("scikit-navbar");
    if (topNav.className === "navbar") {
        topNav.className += " responsive";
    } else {
        topNav.className = "navbar";
    }
  };
</script>

  </head><body>

<div class="header-wrapper">
  <div class="header">
      <p class="logo"><a href="../index.html">
          <img src="../_static/scikit-learn-logo-small.png" alt="Logo"/>
      </a>
      </p><div class="navbar" id="scikit-navbar">
          <ul>
              <li><a href="../index.html">首页</a></li>
              <li><a href="../install.html">安装</a></li>
              <li class="btn-li">
                <div class="btn-group">
                    <a href="../documentation.html">文档</a>
                    <a class="btn dropdown-toggle" data-toggle="dropdown">
                      <span class="caret"></span>
                    </a>
                    <ul class="dropdown-menu">
                      <li class="link-title">Scikit-learn 0.19</li>
                      <li><a href="../tutorial/index.html">教程</a></li>
                      <li><a href="../user_guide.html">用户指南</a></li>
                      <li><a href="classes.html">API</a></li>
                      <li><a href="../faq.html">FAQ</a></li>
                      <li><a href="../developers/contributing.html">贡献</a></li>
                      <li class="divider"></li>
                      <li><a href="http://scikit-learn.org/stable/documentation.html">Scikit-learn 0.19 (stable)</a></li>
                      <li><a href="http://scikit-learn.org/0.18/documentation.html">Scikit-learn 0.18</a></li>
                      <li><a href="http://scikit-learn.org/0.17/documentation.html">Scikit-learn 0.17</a></li>
                      <li><a href="../_downloads/scikit-learn-docs.pdf">PDF 文档</a></li>
                    </ul>
                </div>
              </li>
              <li><a href="../auto_examples/index.html">示例</a></li>
              <li><a href="../project-timeline.html">时光轴</a></li>
              <li class="btn-li">
                <div class="btn-group">
                    <a href="javascript:void(0)">项目相关</a>
                    <a class="btn dropdown-toggle" data-toggle="dropdown">
                      <span class="caret"></span>
                    </a>
                    <ul class="dropdown-menu">
                      <li><a href="../project-role.html">项目角色</a></li>
                      <li><a href="../project-check-progress.html">校验进度</a></li>
                      <li><a href="../project-translation-progress.html">翻译进度</a></li>
                      <li><a href="//github.com/apachecn/scikit-learn-doc-zh#%E8%B4%A1%E7%8C%AE%E8%80%85" target="_blank">贡献者</a></li>
                      <li class="divider"></li>
                      <li><a href="../project-timeline.html">时光轴</a></li>
                      <li class="divider"></li>
                      <li><a href="../project-reward.html">项目奖励</a></li>
                      <li class="divider"></li>
                      <li><a href="http://www.apachecn.org/organization/244.html" target="_blank">积分物品</a></li>
                      <li><a href="http://www.apachecn.org/organization/269.html" target="_blank">兑换记录</a></li>
                      <li class="divider"></li>
                      <li><a href="../project-feedback.html">建议反馈</a></li>
                      <li><a href="../project-communication-group.html">技术交流</a></li>
                    </ul>
                </div>
              </li>
              <li><a href="//github.com/apachecn/scikit-learn-doc-zh#%E8%B4%A1%E7%8C%AE%E8%80%85" target="_blank">贡献者</a></li>
              <li><a href="//github.com/apachecn/scikit-learn-doc-zh" target="_blank">GitHub</a></li>
          </ul>
          <a href="javascript:void(0);" onclick="showMenu()">
              <div class="nav-icon">
                  <div class="hamburger-line"></div>
                  <div class="hamburger-line"></div>
                  <div class="hamburger-line"></div>
              </div>
          </a>
          <div class="search_form">
              <div class="gcse-search" id="cse" style="width: 100%;"></div>
          </div>
      </div> <!-- end navbar --></div>
</div>


<!-- Github "fork me" ribbon -->
<a href="https://github.com/apachecn/scikit-learn-doc-zh">
<img class="fork-me"
     style="position: absolute; top: 0; right: 0; border: 0;"
     src="../_static/img/starme.png"
     alt="Star me on GitHub" />
</a>

<div class="content-wrapper">
  <div class="sphinxsidebar">
  <div class="sphinxsidebarwrapper">
      <div class="rel">
  
      <div class="rellink">
      <a href="manifold.html"
      accesskey="P">Previous
      <br/>
      <span class="smallrellink">
      2.2. 流形学习
      </span>
          <span class="hiddenrellink">
          2.2. 流形学习
          </span>
      </a>
      </div>
          <div class="spacer">
          &nbsp;
          </div>
      <div class="rellink">
      <a href="biclustering.html"
      accesskey="N">Next
      <br/>
      <span class="smallrellink">
      2.4. 双聚类
      </span>
          <span class="hiddenrellink">
          2.4. 双聚类
          </span>
      </a>
      </div>

  <!-- Ad a link to the 'up' page -->
      <div class="spacer">
      &nbsp;
      </div>
      <div class="rellink">
      <a href="../unsupervised_learning.html">
      Up
      <br/>
      <span class="smallrellink">
      2. 无监督学习
      </span>
          <span class="hiddenrellink">
          2. 无监督学习
          </span>
          
      </a>
      </div>
  </div>
  
    <p class="doc-version"><b>scikit-learn v0.19.0</b><br/>
    <a href="http://scikit-learn.org/stable/support.html#documentation-resources">Other versions</a></p>
  <p class="citing">Please <b><a href="../about.html#citing-scikit-learn" style="font-size: 110%;">cite us </a></b>if you use the software.</p>
  <ul>
<li><a class="reference internal" href="#">2.3. 聚类</a><ul>
<li><a class="reference internal" href="#id2">2.3.1. 聚类方法概述</a></li>
<li><a class="reference internal" href="#k-means">2.3.2. K-means</a><ul>
<li><a class="reference internal" href="#mini-batch-kmeans">2.3.2.1. 小批量 K-Means</a></li>
</ul>
</li>
<li><a class="reference internal" href="#affinity-propagation">2.3.3. Affinity Propagation</a></li>
<li><a class="reference internal" href="#mean-shift">2.3.4. Mean Shift</a></li>
<li><a class="reference internal" href="#spectral-clustering">2.3.5. Spectral clustering</a><ul>
<li><a class="reference internal" href="#id10">2.3.5.1. 不同的标记分配策略</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hierarchical-clustering">2.3.6. 层次聚类</a><ul>
<li><a class="reference internal" href="#different-linkage-type-ward-complete-and-average-linkage">2.3.6.1. Different linkage type: Ward, complete and average linkage</a></li>
<li><a class="reference internal" href="#id12">2.3.6.2. 添加连接约束</a></li>
<li><a class="reference internal" href="#varying-the-metric">2.3.6.3. Varying the metric</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dbscan">2.3.7. DBSCAN</a></li>
<li><a class="reference internal" href="#birch">2.3.8. Birch</a></li>
<li><a class="reference internal" href="#clustering-evaluation">2.3.9. 聚类性能度量</a><ul>
<li><a class="reference internal" href="#rand">2.3.9.1. 调整后的 Rand 指数</a><ul>
<li><a class="reference internal" href="#id24">2.3.9.1.1. 优点</a></li>
<li><a class="reference internal" href="#id25">2.3.9.1.2. 缺点</a></li>
<li><a class="reference internal" href="#id26">2.3.9.1.3. 数学表达</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mutual-information">2.3.9.2. 基于 Mutual Information （互信息）的分数</a><ul>
<li><a class="reference internal" href="#id27">2.3.9.2.1. 优点</a></li>
<li><a class="reference internal" href="#id28">2.3.9.2.2. 缺点</a></li>
<li><a class="reference internal" href="#id29">2.3.9.2.3. 数学公式</a></li>
</ul>
</li>
<li><a class="reference internal" href="#v-measure">2.3.9.3. 同质性，完整性和 V-measure</a><ul>
<li><a class="reference internal" href="#id32">2.3.9.3.1. 优点</a></li>
<li><a class="reference internal" href="#id33">2.3.9.3.2. 缺点</a></li>
<li><a class="reference internal" href="#id34">2.3.9.3.3. 数学表达</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fowlkes-mallows">2.3.9.4. Fowlkes-Mallows 分数</a><ul>
<li><a class="reference internal" href="#id35">2.3.9.4.1. 优点</a></li>
<li><a class="reference internal" href="#id36">2.3.9.4.2. 缺点</a></li>
</ul>
</li>
<li><a class="reference internal" href="#silhouette">2.3.9.5. Silhouette 系数</a><ul>
<li><a class="reference internal" href="#id37">2.3.9.5.1. 优点</a></li>
<li><a class="reference internal" href="#id38">2.3.9.5.2. 缺点</a></li>
</ul>
</li>
<li><a class="reference internal" href="#calinski-harabaz">2.3.9.6. Calinski-Harabaz 指数</a><ul>
<li><a class="reference internal" href="#id39">2.3.9.6.1. 优点</a></li>
<li><a class="reference internal" href="#id40">2.3.9.6.2. 缺点</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<input type="checkbox" id="nav-trigger" class="nav-trigger" checked />
<label for="nav-trigger"></label>




    <div class="content">
          
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="clustering">
<span id="id1"></span><h1>2.3. 聚类<a class="headerlink" href="#clustering" title="Permalink to this headline">¶</a></h1>
<p>未标记的数据的 <a class="reference external" href="https://en.wikipedia.org/wiki/Cluster_analysis">Clustering（聚类）</a> 可以使用模块 <a class="reference internal" href="classes.html#module-sklearn.cluster" title="sklearn.cluster"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.cluster</span></code></a> 来实现。</p>
<p>每个 clustering algorithm （聚类算法）有两个变体: 一个是 class, 它实现了 <code class="docutils literal notranslate"><span class="pre">fit</span></code> 方法来学习 train data（训练数据）的 clusters（聚类），还有一个 function（函数），是给定 train data（训练数据），返回与不同 clusters（聚类）对应的整数标签 array（数组）。对于 class（类），training data（训练数据）上的标签可以在 <code class="docutils literal notranslate"><span class="pre">labels_</span></code> 属性中找到。</p>
<div class="topic">
<p class="topic-title first">输入数据</p>
<p>需要注意的一点是，该模块中实现的算法可以采用不同种类的 matrix （矩阵）作为输入。所有这些都接受 shape <code class="docutils literal notranslate"><span class="pre">[n_samples,</span> <span class="pre">n_features]</span></code> 的标准数据矩阵。
这些可以从以下的 <a class="reference internal" href="classes.html#module-sklearn.feature_extraction" title="sklearn.feature_extraction"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.feature_extraction</span></code></a> 模块的 classes （类）中获得。对于 <a class="reference internal" href="generated/sklearn.cluster.AffinityPropagation.html#sklearn.cluster.AffinityPropagation" title="sklearn.cluster.AffinityPropagation"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffinityPropagation</span></code></a>, <a class="reference internal" href="generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" title="sklearn.cluster.SpectralClustering"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpectralClustering</span></code></a> 和 <a class="reference internal" href="generated/sklearn.cluster.DBSCAN.html#sklearn.cluster.DBSCAN" title="sklearn.cluster.DBSCAN"><code class="xref py py-class docutils literal notranslate"><span class="pre">DBSCAN</span></code></a> 也可以输入 shape <code class="docutils literal notranslate"><span class="pre">[n_samples,</span> <span class="pre">n_samples]</span></code> 的相似矩阵。这些可以从 <a class="reference internal" href="classes.html#module-sklearn.metrics.pairwise" title="sklearn.metrics.pairwise"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.metrics.pairwise</span></code></a> 模块中的函数获得。</p>
</div>
<div class="section" id="id2">
<h2>2.3.1. 聚类方法概述<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<div class="figure align-center" id="id41">
<a class="reference external image-reference" href="../auto_examples/cluster/plot_cluster_comparison.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_cluster_comparison_001.png" src="modules/../auto_examples/cluster/images/sphx_glr_plot_cluster_comparison_001.png" /></a>
<p class="caption"><span class="caption-text">在 scikit-learn 中的 clustering algorithms （聚类算法）的比较</span></p>
</div>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="15%" />
<col width="16%" />
<col width="20%" />
<col width="27%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name（方法名称）</th>
<th class="head">Parameters（参数）</th>
<th class="head">Scalability（可扩展性）</th>
<th class="head">Usecase（使用场景）</th>
<th class="head">Geometry (metric used)（几何图形（公制使用））</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#k-means"><span class="std std-ref">K-Means（K-均值）</span></a></td>
<td>number of clusters（聚类形成的簇的个数）</td>
<td>非常大的 <code class="docutils literal notranslate"><span class="pre">n_samples</span></code>, 中等的 <code class="docutils literal notranslate"><span class="pre">n_clusters</span></code> 使用
<a class="reference internal" href="#mini-batch-kmeans"><span class="std std-ref">MiniBatch code（MiniBatch 代码）</span></a></td>
<td>通用, 均匀的 cluster size（簇大小）, flat geometry（平面几何）, 不是太多的 clusters（簇）</td>
<td>Distances between points（点之间的距离）</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#affinity-propagation"><span class="std std-ref">Affinity propagation</span></a></td>
<td>damping（阻尼）, sample preference（样本偏好）</td>
<td>Not scalable with n_samples（n_samples 不可扩展）</td>
<td>Many clusters, uneven cluster size, non-flat geometry（许多簇，不均匀的簇大小，非平面几何）</td>
<td>Graph distance (e.g. nearest-neighbor graph)（图形距离（例如，最近邻图））</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mean-shift"><span class="std std-ref">Mean-shift</span></a></td>
<td>bandwidth（带宽）</td>
<td>Not scalable with <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> （不可扩展的 <code class="docutils literal notranslate"><span class="pre">n_samples</span></code>）</td>
<td>Many clusters, uneven cluster size, non-flat geometry（许多簇，不均匀的簇大小，非平面几何）</td>
<td>Distances between points（点之间的距离）</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spectral-clustering"><span class="std std-ref">Spectral clustering</span></a></td>
<td>number of clusters（簇的个数）</td>
<td>中等的 <code class="docutils literal notranslate"><span class="pre">n_samples</span></code>, 小的 <code class="docutils literal notranslate"><span class="pre">n_clusters</span></code></td>
<td>Few clusters, even cluster size, non-flat geometry（几个簇，均匀的簇大小，非平面几何）</td>
<td>Graph distance (e.g. nearest-neighbor graph)（图形距离（例如最近邻图））</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hierarchical-clustering"><span class="std std-ref">Ward hierarchical clustering</span></a></td>
<td>number of clusters（簇的个数）</td>
<td>大的 <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> 和 <code class="docutils literal notranslate"><span class="pre">n_clusters</span></code></td>
<td>Many clusters, possibly connectivity constraints（很多的簇，可能连接限制）</td>
<td>Distances between points（点之间的距离）</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hierarchical-clustering"><span class="std std-ref">Agglomerative clustering</span></a></td>
<td>number of clusters（簇的个数）, linkage type（链接类型）, distance（距离）</td>
<td>大的 <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> 和 <code class="docutils literal notranslate"><span class="pre">n_clusters</span></code></td>
<td>Many clusters, possibly connectivity constraints, non Euclidean distances（很多簇，可能连接限制，非欧几里得距离）</td>
<td>Any pairwise distance（任意成对距离）</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dbscan"><span class="std std-ref">DBSCAN</span></a></td>
<td>neighborhood size（neighborhood 的大小）</td>
<td>非常大的 <code class="docutils literal notranslate"><span class="pre">n_samples</span></code>, 中等的 <code class="docutils literal notranslate"><span class="pre">n_clusters</span></code></td>
<td>Non-flat geometry, uneven cluster sizes（非平面几何，不均匀的簇大小）</td>
<td>Distances between nearest points（最近点之间的距离）</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="mixture.html#mixture"><span class="std std-ref">Gaussian mixtures（高斯混合）</span></a></td>
<td>many（很多）</td>
<td>Not scalable（不可扩展）</td>
<td>Flat geometry, good for density estimation（平面几何，适用于密度估计）</td>
<td>Mahalanobis distances to  centers（Mahalanobis 与中心的距离）</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#birch"><span class="std std-ref">Birch</span></a></td>
<td>branching factor（分支因子）, threshold（阈值）, optional global clusterer（可选全局簇）.</td>
<td>大的 <code class="docutils literal notranslate"><span class="pre">n_clusters</span></code> 和 <code class="docutils literal notranslate"><span class="pre">n_samples</span></code></td>
<td>Large dataset, outlier removal, data reduction.（大数据集，异常值去除，数据简化）</td>
<td>Euclidean distance between points（点之间的欧式距离）</td>
</tr>
</tbody>
</table>
<p>当 clusters （簇）具有 specific shape （特殊的形状），即 non-flat manifold（非平面 manifold），并且标准欧几里得距离不是正确的 metric （度量标准）时，Non-flat geometry clustering （非平面几何聚类）是非常有用的。这种情况出现在上图的两个顶行中。</p>
<p>用于 clustering （聚类）的 Gaussian mixture models （高斯混合模型），专用于 mixture models （混合模型）描述在 <a class="reference internal" href="mixture.html#mixture"><span class="std std-ref">文档的另一章节</span></a> 。可以将 KMeans 视为具有 equal covariance per component （每个分量相等协方差）的 Gaussian mixture model （高斯混合模型）的特殊情况。</p>
</div>
<div class="section" id="k-means">
<span id="id3"></span><h2>2.3.2. K-means<a class="headerlink" href="#k-means" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">KMeans</span></code></a> 算法通过试图分离 n groups of equal variance（n 个相等方差组）的样本来聚集数据，minimizing （最小化）称为 <a class="reference external" href="inertia">inertia</a> 或者 within-cluster sum-of-squares （簇内和平方）的 criterion （标准）。
该算法需要指定 number of clusters （簇的数量）。它可以很好地 scales （扩展）到 large number of samples（大量样本），并已经被广泛应用于许多不同领域的应用领域。</p>
<p>k-means 算法将一组 <span class="math">N</span> 样本 <span class="math">X</span> 划分成 <span class="math">K</span> 不相交的 clusters （簇） <span class="math">C</span>, 每个都用 cluster （该簇）中的样本的均值 <span class="math">\mu_j</span> 描述。
这个 means （均值）通常被称为 cluster（簇）的 “centroids（质心）”; 注意，它们一般不是从 <span class="math">X</span> 中挑选出的点，虽然它们是处在同一个 space（空间）。
K-means（K-均值）算法旨在选择最小化 <em>inertia（惯性）</em> 或  within-cluster sum of squared（簇内和的平方和）的标准的 centroids（质心）:</p>
<div class="math">
<p><span class="math">\sum_{i=0}^{n}\min_{\mu_j \in C}(||x_j - \mu_i||^2)</span></p>
</div><p>Inertia（惯性）, 或 the within-cluster sum of squares（簇内和平方差） criterion（标准）,可以被认为是 internally coherent clusters （内相干簇）的 measure （度量）。
它有各种缺点:</p>
<ul class="simple">
<li>Inertia（惯性）假设 clusters （簇）是 convex（凸）的和 isotropic （各项同性），这并不是总是这样。它对 elongated clusters （细长的簇）或具有不规则形状的 manifolds 反应不佳。</li>
<li>Inertia（惯性）不是一个 normalized metric（归一化度量）: 我们只知道 lower values （较低的值）是更好的，并且 零 是最优的。但是在 very high-dimensional spaces （非常高维的空间）中，欧几里得距离往往会变得 inflated （膨胀）（这就是所谓的 “curse of dimensionality （维度诅咒/维度惩罚）”）。在 k-means 聚类之前运行诸如 <a class="reference external" href="PCA">PCA</a> 之类的 dimensionality reduction algorithm （降维算法）可以减轻这个问题并加快计算速度。</li>
</ul>
<a class="reference external image-reference" href="../auto_examples/cluster/plot_kmeans_assumptions.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_kmeans_assumptions_001.png" class="align-center" src="modules/../auto_examples/cluster/images/sphx_glr_plot_kmeans_assumptions_001.png" /></a>
<p>K-means 通常被称为 Lloyd’s algorithm（劳埃德算法）。在基本术语中，算法有三个步骤。、
第一步是选择 initial centroids （初始质心），最基本的方法是从 <span class="math">X</span> 数据集中选择 <span class="math">k</span> 个样本。初始化完成后，K-means 由两个其他步骤之间的循环组成。
第一步将每个样本分配到其 nearest centroid （最近的质心）。第二步通过取分配给每个先前质心的所有样本的平均值来创建新的质心。计算旧的和新的质心之间的差异，并且算法重复这些最后的两个步骤，直到该值小于阈值。换句话说，算法重复这个步骤，直到质心不再显著移动。</p>
<a class="reference external image-reference" href="../auto_examples/cluster/plot_kmeans_digits.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_kmeans_digits_001.png" class="align-right" src="modules/../auto_examples/cluster/images/sphx_glr_plot_kmeans_digits_001.png" /></a>
<p>K-means 相当于具有 small, all-equal, diagonal covariance matrix （小的全对称协方差矩阵）的 expectation-maximization algorithm （期望最大化算法）。</p>
<p>该算法也可以通过 <a href="#id42"><span class="problematic" id="id43">`Voronoi diagrams（Voronoi图）&lt;https://en.wikipedia.org/wiki/Voronoi_diagram&gt;`_</span></a> 的概念来理解。首先使用 current centroids （当前质心）计算点的 Voronoi 图。
Voronoi 图中的每个 segment （段）都成为一个 separate cluster （单独的簇）。其次，centroids（质心）被更新为每个 segment （段）的 mean（平均值）。然后，该算法重复此操作，直到满足停止条件。
通常情况下，当 iterations （迭代）之间的 objective function （目标函数）的相对减小小于给定的 tolerance value （公差值）时，算法停止。在此实现中不是这样: 当质心移动小于 tolerance （公差）时，迭代停止。</p>
<p>给定足够的时间，K-means 将总是收敛的，但这可能是 local minimum （局部最小）的。这很大程度上取决于 initialization of the centroids （质心的初始化）。
因此，通常会进行几次 different initializations of the centroids （初始化不同质心）的计算。帮助解决这个问题的一种方法是 k-means++ 初始化方案，它已经在 scikit-learn 中实现（使用 <code class="docutils literal notranslate"><span class="pre">init='k-means++'</span></code> 参数）。
这将初始化 centroids （质心）（通常）彼此远离，导致比随机初始化更好的结果，如参考文献所示。</p>
<p>可以给出一个参数，以允许 K-means 并行运行，称为 <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code>。给这个参数一个正值使用许多处理器（默认值: 1）。值 -1 使用所有可用的处理器，-2 使用一个，等等。Parallelization （并行化）通常以 cost of memory（内存的代价）加速计算（在这种情况下，需要存储多个质心副本，每个作业使用一个）。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">当 <cite>numpy</cite> 使用 <cite>Accelerate</cite> 框架时，K-Means 的并行版本在 OS X 上损坏。这是 expected behavior （预期的行为）: <cite>Accelerate</cite> 可以在 fork 之后调用，但是您需要使用 Python binary（二进制）（该多进程在 posix 下不执行）来执行子进程。</p>
</div>
<p>K-means 可用于 vector quantization （矢量量化）。这是使用以下类型的 trained model （训练模型）的变换方法实现的 <a class="reference internal" href="generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">KMeans</span></code></a> 。</p>
<div class="topic">
<p class="topic-title first">示例:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_kmeans_assumptions.html#sphx-glr-auto-examples-cluster-plot-kmeans-assumptions-py"><span class="std std-ref">k-means 假设的示范</span></a>: 演示 k-means 是否 performs intuitively （直观执行），何时不执行</li>
<li><a class="reference internal" href="../auto_examples/cluster/plot_kmeans_digits.html#sphx-glr-auto-examples-cluster-plot-kmeans-digits-py"><span class="std std-ref">A demo of K-Means clustering on the handwritten digits data</span></a>: 聚类手写数字</li>
</ul>
</div>
<div class="topic">
<p class="topic-title first">参考:</p>
<ul class="simple">
<li><a class="reference external" href="http://ilpubs.stanford.edu:8090/778/1/2006-13.pdf">“k-means++: The advantages of careful seeding”</a>
Arthur, David, and Sergei Vassilvitskii,
<em>Proceedings of the eighteenth annual ACM-SIAM symposium on Discrete
algorithms</em>, Society for Industrial and Applied Mathematics (2007)</li>
</ul>
</div>
<div class="section" id="mini-batch-kmeans">
<span id="id4"></span><h3>2.3.2.1. 小批量 K-Means<a class="headerlink" href="#mini-batch-kmeans" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.cluster.MiniBatchKMeans.html#sklearn.cluster.MiniBatchKMeans" title="sklearn.cluster.MiniBatchKMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">MiniBatchKMeans</span></code></a> 是 <a class="reference internal" href="generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">KMeans</span></code></a> 算法的一个变体，它使用 mini-batches （小批量）来减少计算时间，同时仍然尝试优化相同的 objective function （目标函数）。
Mini-batches（小批量）是输入数据的子集，在每次 training iteration （训练迭代）中 randomly sampled （随机抽样）。这些小批量大大减少了融合到本地解决方案所需的计算量。
与其他降低 k-means 收敛时间的算法相反，mini-batch k-means 产生的结果通常只比标准算法略差。</p>
<p>该算法在两个主要步骤之间进行迭代，类似于 vanilla k-means 。
在第一步， <span class="math">b</span> 样本是从数据集中随机抽取的，形成一个 mini-batch （小批量）。然后将它们分配到最近的 centroid（质心）。
在第二步，centroids （质心）被更新。与 k-means 相反，这是在每个样本的基础上完成的。对于 mini-batch （小批量）中的每个样本，通过取样本的 streaming average （流平均值）和分配给该质心的所有先前样本来更新分配的质心。
这具有随时间降低 centroid （质心）的 rate （变化率）的效果。执行这些步骤直到达到收敛或达到预定次数的迭代。</p>
<p><a class="reference internal" href="generated/sklearn.cluster.MiniBatchKMeans.html#sklearn.cluster.MiniBatchKMeans" title="sklearn.cluster.MiniBatchKMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">MiniBatchKMeans</span></code></a> 收敛速度比 <a class="reference internal" href="generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">KMeans</span></code></a> ，但是结果的质量会降低。在实践中，质量差异可能相当小，如示例和引用的参考。</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/cluster/plot_mini_batch_kmeans.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_mini_batch_kmeans_001.png" src="modules/../auto_examples/cluster/images/sphx_glr_plot_mini_batch_kmeans_001.png" /></a>
</div>
<div class="topic">
<p class="topic-title first">示例:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_mini_batch_kmeans.html#sphx-glr-auto-examples-cluster-plot-mini-batch-kmeans-py"><span class="std std-ref">K-Means 和 MiniBatchKMeans 聚类算法的比较</span></a>: KMeans 与 MiniBatchKMeans 的比较</li>
<li><a class="reference internal" href="../auto_examples/text/document_clustering.html#sphx-glr-auto-examples-text-document-clustering-py"><span class="std std-ref">Clustering text documents using k-means</span></a>: 使用 sparse MiniBatchKMeans （稀疏 MiniBatchKMeans）的文档聚类</li>
<li><a class="reference internal" href="../auto_examples/cluster/plot_dict_face_patches.html#sphx-glr-auto-examples-cluster-plot-dict-face-patches-py"><span class="std std-ref">Online learning of a dictionary of parts of faces</span></a></li>
</ul>
</div>
<div class="topic">
<p class="topic-title first">参考:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.eecs.tufts.edu/~dsculley/papers/fastkmeans.pdf">“Web Scale K-Means clustering”</a>
D. Sculley, <em>Proceedings of the 19th international conference on World
wide web</em> (2010)</li>
</ul>
</div>
</div>
</div>
<div class="section" id="affinity-propagation">
<span id="id5"></span><h2>2.3.3. Affinity Propagation<a class="headerlink" href="#affinity-propagation" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="generated/sklearn.cluster.AffinityPropagation.html#sklearn.cluster.AffinityPropagation" title="sklearn.cluster.AffinityPropagation"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffinityPropagation</span></code></a> AP聚类是通过在样本对之间发送消息直到收敛来创建聚类。然后使用少量示例样本作为聚类中心来描述数据集，
聚类中心是数据集中最能代表一类数据的样本。在样本对之间发送的消息表示一个样本作为另一个样本的示例样本的
适合程度，适合程度值在根据通信的反馈不断更新。更新迭代直到收敛，完成聚类中心的选取，因此也给出了最终聚类。</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/cluster/plot_affinity_propagation.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_affinity_propagation_001.png" src="modules/../auto_examples/cluster/images/sphx_glr_plot_affinity_propagation_001.png" /></a>
</div>
<dl class="docutils">
<dt>Affinity Propagation 算法比较有趣的是可以根据提供的数据决定聚类的数目。 因此有两个比较重要的参数</dt>
<dd><em>preference</em>, 决定使用多少个示例样本  <a href="#id6"><span class="problematic" id="id7">*</span></a>damping factor*（阻尼因子） 减少吸引信息和归属信息以防止
更新减少吸引度和归属度信息时数据振荡。</dd>
</dl>
<p>AP聚类算法主要的缺点是算法的复杂度. AP聚类算法的时间复杂度是 <span class="math">O(N^2 T)</span>, 其中 <span class="math">N</span>
是样本的个数 ， <span class="math">T</span> 是收敛之前迭代的次数. 如果使用密集的相似性矩阵空间复杂度是
<span class="math">O(N^2)</span> 如果使用稀疏的相似性矩阵空间复杂度可以降低。 这使得AP聚类最适合中小型数据集。</p>
<div class="topic">
<p class="topic-title first">示例:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_affinity_propagation.html#sphx-glr-auto-examples-cluster-plot-affinity-propagation-py"><span class="std std-ref">Demo of affinity propagation clustering algorithm</span></a>: Affinity
Propagation on a synthetic 2D datasets with 3 classes.</li>
<li><a class="reference internal" href="../auto_examples/applications/plot_stock_market.html#sphx-glr-auto-examples-applications-plot-stock-market-py"><span class="std std-ref">Visualizing the stock market structure</span></a> Affinity Propagation on
Financial time series to find groups of companies</li>
</ul>
</div>
<p><strong>Algorithm description(算法描述):</strong>
样本之间传递的信息有两种。 第一种是 responsibility(吸引信息) <span class="math">r(i, k)</span>, 样本 <span class="math">k</span> 适合作为样本 <span class="math">i</span> 的聚类中心的程度。</p>
<p>第二种是 availability(归属信息) <span class="math">a(i, k)</span> 样本 <span class="math">i</span> 选择样本 <span class="math">k</span> 作为聚类中心的适合程度,并且考虑其他所有样本选取 <span class="math">k</span> 做为聚类中心的合适程度。
通过这个方法，选取示例样本作为聚类中心如果 (1) 该样本与其许多样本相似，并且 (2) 被许多样本选取
为它们自己的示例样本。</p>
<p>样本 <span class="math">k</span> 对样本 <span class="math">i</span> 吸引度计算公式:</p>
<div class="math">
<p><span class="math">r(i, k) \leftarrow s(i, k) - max [ a(i, k') + s(i, k') \forall k' \neq k ]</span></p>
</div><p>其中 <span class="math">s(i, k)</span> 是样本 <span class="math">i</span> 和样本 <span class="math">k</span> 之间的相似度。
样本 <span class="math">k</span> 作为样本 <span class="math">i</span> 的示例样本的合适程度:</p>
<div class="math">
<p><span class="math">a(i, k) \leftarrow min [0, r(k, k) + \sum_{i'~s.t.~i' \notin \{i, k\}}{r(i', k)}]</span></p>
</div><p>算法开始时 <span class="math">r</span> 和 <span class="math">a</span> 都被置 0,然后开始迭代计算直到收敛。
为了防止更新数据时出现数据振荡，在迭代过程中引入阻尼因子 <span class="math">\lambda</span> :</p>
<div class="math">
<p><span class="math">r_{t+1}(i, k) = \lambda\cdot r_{t}(i, k) + (1-\lambda)\cdot r_{t+1}(i, k)</span></p>
</div><div class="math">
<p><span class="math">a_{t+1}(i, k) = \lambda\cdot a_{t}(i, k) + (1-\lambda)\cdot a_{t+1}(i, k)</span></p>
</div><p>其中 <span class="math">t</span> 迭代的次数。</p>
</div>
<div class="section" id="mean-shift">
<span id="id8"></span><h2>2.3.4. Mean Shift<a class="headerlink" href="#mean-shift" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="generated/sklearn.cluster.MeanShift.html#sklearn.cluster.MeanShift" title="sklearn.cluster.MeanShift"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeanShift</span></code></a> 算法旨在于发现一个样本密度平滑的 <em>blobs</em> 。
均值漂移算法是基于质心的算法，通过更新质心的候选位置为所选定区域的偏移均值。
然后，这些候选者在后处理阶段被过滤以消除近似重复，从而形成最终质心集合。</p>
<p>给定第 <span class="math">t</span> 次迭代中的候选质心 <span class="math">x_i</span> , 候选质心的位置将被安装如下公式更新:</p>
<div class="math">
<p><span class="math">x_i^{t+1} = x_i^t + m(x_i^t)</span></p>
</div><p>其中 <span class="math">N(x_i)</span> 是围绕 <span class="math">x_i</span> 周围一个给定距离范围内的样本空间
and <span class="math">m</span> 是  <em>mean shift</em> vector（均值偏移向量） 是所有质心中指向
点密度增加最多的区域的偏移向量。使用以下等式计算，有效地将质心更新为其邻域内样本的平均值:</p>
<div class="math">
<p><span class="math">m(x_i) = \frac{\sum_{x_j \in N(x_i)}K(x_j - x_i)x_j}{\sum_{x_j \in N(x_i)}K(x_j - x_i)}</span></p>
</div><p>算法自动设定聚类的数目，取代依赖参数 <code class="docutils literal notranslate"><span class="pre">bandwidth``（带宽）,带宽是决定搜索区域的size的参数。</span>
<span class="pre">这个参数可以手动设置，但是如果没有设置，可以使用提供的评估函数</span> <span class="pre">``estimate_bandwidth</span></code> 进行评估。</p>
<p>该算法不是高度可扩展的，因为在执行算法期间需要执行多个最近邻搜索。 该算法保证收敛，但是当
质心的变化较小时，算法将停止迭代。</p>
<p>通过找到给定样本的最近质心来给新样本打上标签。</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/cluster/plot_mean_shift.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_mean_shift_001.png" src="modules/../auto_examples/cluster/images/sphx_glr_plot_mean_shift_001.png" /></a>
</div>
<div class="topic">
<p class="topic-title first">示例:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_mean_shift.html#sphx-glr-auto-examples-cluster-plot-mean-shift-py"><span class="std std-ref">mean-shift（均值漂移）聚类算法示例</span></a>: Mean Shift clustering
on a synthetic 2D datasets with 3 classes.</li>
</ul>
</div>
<div class="topic">
<p class="topic-title first">参考:</p>
<ul class="simple">
<li><a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.76.8968&amp;rep=rep1&amp;type=pdf">“Mean shift: A robust approach toward feature space analysis.”</a>
D. Comaniciu and P. Meer, <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> (2002)</li>
</ul>
</div>
</div>
<div class="section" id="spectral-clustering">
<span id="id9"></span><h2>2.3.5. Spectral clustering<a class="headerlink" href="#spectral-clustering" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" title="sklearn.cluster.SpectralClustering"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpectralClustering</span></code></a> 是在样本之间进行亲和力矩阵的低维度嵌入，其实是低维空间中的 KMeans。
如果亲和度矩阵稀疏，则这是非常有效的并且 <a class="reference external" href="http://pyamg.org/">pyamg</a> module 以及安装好。
SpectralClustering 需要指定聚类数。这个算法适用于聚类数少时，在聚类数多是不建议使用。</p>
<p>对于两个聚类，它解决了相似图上的 <a class="reference external" href="http://people.eecs.berkeley.edu/~malik/papers/SM-ncut.pdf">normalised cuts</a> 问题:
将图形切割成两个，使得切割的边缘的重量比每个簇内的边缘的权重小。在图像处理时，这个标准是特别有趣的:
图像的顶点是像素，相似图的边缘是图像的渐变函数。</p>
<p class="centered">
<strong><a class="reference external" href="../auto_examples/cluster/plot_segmentation_toy.html"><img alt="noisy_img" src="modules/../auto_examples/cluster/images/sphx_glr_plot_segmentation_toy_001.png" /></a> <a class="reference external" href="../auto_examples/cluster/plot_segmentation_toy.html"><img alt="segmented_img" src="modules/../auto_examples/cluster/images/sphx_glr_plot_segmentation_toy_002.png" /></a></strong></p><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Transforming distance to well-behaved similarities</p>
<p>请注意，如果你的相似矩阵的值分布不均匀，例如:存在负值或者距离矩阵并不表示相似性
spectral problem 将会变得奇异，并且不能解决。
在这种情况下，建议对矩阵的 entries 进行转换。比如在符号距离有符号的情况下通常使用 heat kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">similarity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span> <span class="o">*</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">distance</span><span class="o">.</span><span class="n">std</span><span class="p">())</span>
</pre></div>
</div>
<p class="last">请看这样一个应用程序的例子。</p>
</div>
<div class="topic">
<p class="topic-title first">示例:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_segmentation_toy.html#sphx-glr-auto-examples-cluster-plot-segmentation-toy-py"><span class="std std-ref">Spectral clustering for image segmentation</span></a>: Segmenting objects
from a noisy background using spectral clustering.</li>
<li><a class="reference internal" href="../auto_examples/cluster/plot_face_segmentation.html#sphx-glr-auto-examples-cluster-plot-face-segmentation-py"><span class="std std-ref">Segmenting the picture of a raccoon face in regions</span></a>: Spectral clustering
to split the image of the raccoon face in regions.</li>
</ul>
</div>
<div class="section" id="id10">
<h3>2.3.5.1. 不同的标记分配策略<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>可以使用不同的分配策略, 对应于 <code class="docutils literal notranslate"><span class="pre">assign_labels</span></code> 参数 <a class="reference internal" href="generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" title="sklearn.cluster.SpectralClustering"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpectralClustering</span></code></a>。
<code class="docutils literal notranslate"><span class="pre">&quot;kmeans&quot;</span></code> 可以匹配更精细的数据细节，但是可能更加不稳定。 特别是，除非你设置
<code class="docutils literal notranslate"><span class="pre">random_state</span></code> 否则可能无法复现运行的结果 ，因为它取决于随机初始化。另一方，
使用 <code class="docutils literal notranslate"><span class="pre">&quot;discretize&quot;</span></code> 策略是 100% 可以复现的，但是它往往会产生相当均匀的几何形状的边缘。</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><code class="docutils literal notranslate"><span class="pre">assign_labels=&quot;kmeans&quot;</span></code></th>
<th class="head"><code class="docutils literal notranslate"><span class="pre">assign_labels=&quot;discretize&quot;</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference external" href="../auto_examples/cluster/plot_face_segmentation.html"><img alt="face_kmeans" src="modules/../auto_examples/cluster/images/sphx_glr_plot_face_segmentation_001.png" /></a></td>
<td><a class="reference external" href="../auto_examples/cluster/plot_face_segmentation.html"><img alt="face_discretize" src="modules/../auto_examples/cluster/images/sphx_glr_plot_face_segmentation_002.png" /></a></td>
</tr>
</tbody>
</table>
<div class="topic">
<p class="topic-title first">参考:</p>
<ul class="simple">
<li><a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323">“A Tutorial on Spectral Clustering”</a>
Ulrike von Luxburg, 2007</li>
<li><a class="reference external" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324">“Normalized cuts and image segmentation”</a>
Jianbo Shi, Jitendra Malik, 2000</li>
<li><a class="reference external" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.33.1501">“A Random Walks View of Spectral Segmentation”</a>
Marina Meila, Jianbo Shi, 2001</li>
<li><a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.8100">“On Spectral Clustering: Analysis and an algorithm”</a>
Andrew Y. Ng, Michael I. Jordan, Yair Weiss, 2001</li>
</ul>
</div>
</div>
</div>
<div class="section" id="hierarchical-clustering">
<span id="id11"></span><h2>2.3.6. 层次聚类<a class="headerlink" href="#hierarchical-clustering" title="Permalink to this headline">¶</a></h2>
<p>Hierarchical clustering 是一个常用的聚类算法，它通过不断的合并或者分割来构建聚类。
聚类的层次被表示成树（或者 dendrogram（树形图））。树根是拥有所有样本的唯一聚类，叶子是仅有一个样本的聚类。
请参照 <a class="reference external" href="https://en.wikipedia.org/wiki/Hierarchical_clustering">Wikipedia page</a> 查看更多细节。</p>
<p>The <a class="reference internal" href="generated/sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering" title="sklearn.cluster.AgglomerativeClustering"><code class="xref py py-class docutils literal notranslate"><span class="pre">AgglomerativeClustering</span></code></a> 使用自下而上的方法进行层次聚类:开始是每一个对象是一个聚类，
并且聚类别相继合并在一起。 linkage criteria 确定用于合并的策略的度量:</p>
<ul class="simple">
<li><strong>Ward</strong> 最小化所有聚类内的平方差总和。这是一种 variance-minimizing （方差最小化）的优化方向，
这是与k-means 的目标函数相似的优化方法，但是用 agglomerative hierarchical（聚类分层）的方法处理。</li>
<li><strong>Maximum</strong> 或 <strong>complete linkage</strong> 最小化聚类对两个样本之间的最大距离。</li>
<li><strong>Average linkage</strong> 最小化聚类两个聚类中样本距离的平均值。</li>
</ul>
<p><a class="reference internal" href="generated/sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering" title="sklearn.cluster.AgglomerativeClustering"><code class="xref py py-class docutils literal notranslate"><span class="pre">AgglomerativeClustering</span></code></a> 在于连接矩阵联合使用时，也可以扩大到大量的样本，但是
在样本之间没有添加连接约束时，计算代价很大:每一个步骤都要考虑所有可能的合并。</p>
<div class="topic">
<p class="topic-title first"><a class="reference internal" href="generated/sklearn.cluster.FeatureAgglomeration.html#sklearn.cluster.FeatureAgglomeration" title="sklearn.cluster.FeatureAgglomeration"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeatureAgglomeration</span></code></a></p>
<p>The <a class="reference internal" href="generated/sklearn.cluster.FeatureAgglomeration.html#sklearn.cluster.FeatureAgglomeration" title="sklearn.cluster.FeatureAgglomeration"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeatureAgglomeration</span></code></a> 使用 agglomerative clustering 将看上去相似的
特征组合在一起，从而减少特征的数量。这是一个降维工具, 请参照 <a class="reference internal" href="unsupervised_reduction.html#data-reduction"><span class="std std-ref">无监督降维</span></a>。</p>
</div>
<div class="section" id="different-linkage-type-ward-complete-and-average-linkage">
<h3>2.3.6.1. Different linkage type: Ward, complete and average linkage<a class="headerlink" href="#different-linkage-type-ward-complete-and-average-linkage" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering" title="sklearn.cluster.AgglomerativeClustering"><code class="xref py py-class docutils literal notranslate"><span class="pre">AgglomerativeClustering</span></code></a> 支持 Ward, average, and complete
linkage 策略.</p>
<a class="reference external image-reference" href="../auto_examples/cluster/plot_digits_linkage.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_digits_linkage_001.png" src="modules/../auto_examples/cluster/images/sphx_glr_plot_digits_linkage_001.png" /></a>
<a class="reference external image-reference" href="../auto_examples/cluster/plot_digits_linkage.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_digits_linkage_002.png" src="modules/../auto_examples/cluster/images/sphx_glr_plot_digits_linkage_002.png" /></a>
<a class="reference external image-reference" href="../auto_examples/cluster/plot_digits_linkage.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_digits_linkage_003.png" src="modules/../auto_examples/cluster/images/sphx_glr_plot_digits_linkage_003.png" /></a>
<p>Agglomerative cluster 存在 “rich get richer” 现象导致聚类大小不均匀。这方面 complete linkage
是最坏的策略，Ward 给出了最规则的大小。然而，在 Ward 中 affinity (or distance used in clustering)
不能被改变，对于 non Euclidean metrics 来说 average linkage 是一个好的选择。</p>
<div class="topic">
<p class="topic-title first">示例:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_digits_linkage.html#sphx-glr-auto-examples-cluster-plot-digits-linkage-py"><span class="std std-ref">Various Agglomerative Clustering on a 2D embedding of digits</span></a>: exploration of the
different linkage strategies in a real dataset.</li>
</ul>
</div>
</div>
<div class="section" id="id12">
<h3>2.3.6.2. 添加连接约束<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering" title="sklearn.cluster.AgglomerativeClustering"><code class="xref py py-class docutils literal notranslate"><span class="pre">AgglomerativeClustering</span></code></a> 中一个有趣的特点是可以使用 connectivity matrix（连接矩阵）
将连接约束添加到算法中（只有相邻的聚类可以合并到一起），连接矩阵为每一个样本给定了相邻的样本。
例如，在 swiss-roll 的例子中，连接约束禁止在不相邻的 swiss roll 上合并，从而防止形成在 roll 上
重复折叠的聚类。</p>
<p class="centered">
<strong><a class="reference external" href="../auto_examples/cluster/plot_ward_structured_vs_unstructured.html"><img alt="unstructured" src="modules/../auto_examples/cluster/images/sphx_glr_plot_ward_structured_vs_unstructured_001.png" /></a> <a class="reference external" href="../auto_examples/cluster/plot_ward_structured_vs_unstructured.html"><img alt="structured" src="modules/../auto_examples/cluster/images/sphx_glr_plot_ward_structured_vs_unstructured_002.png" /></a></strong></p><p>这些约束对于强加一定的局部结构是很有用的，但是这也使得算法更快，特别是当样本数量巨大时。</p>
<p>连通性的限制是通过连接矩阵来实现的:一个 scipy sparse matrix（稀疏矩阵），仅在一行和
一列的交集处具有应该连接在一起的数据集的索引。这个矩阵可以通过 a-priori information （先验信息）
构建:例如，你可能通过仅仅将从一个连接指向另一个的链接合并页面来聚类页面。也可以从数据中学习到,</p>
<blockquote>
<div>例如使用 <a class="reference internal" href="generated/sklearn.neighbors.kneighbors_graph.html#sklearn.neighbors.kneighbors_graph" title="sklearn.neighbors.kneighbors_graph"><code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.neighbors.kneighbors_graph</span></code></a> 限制与最临近的合并 :ref:<a href="#id13"><span class="problematic" id="id14">`</span></a>this example</div></blockquote>
<dl class="docutils">
<dt>&lt;sphx_glr_auto_examples_cluster_plot_agglomerative_clustering.py&gt;`, 或者使用</dt>
<dd><a class="reference internal" href="generated/sklearn.feature_extraction.image.grid_to_graph.html#sklearn.feature_extraction.image.grid_to_graph" title="sklearn.feature_extraction.image.grid_to_graph"><code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.feature_extraction.image.grid_to_graph</span></code></a> 仅合并图像上相邻的像素点，
例如 <a class="reference internal" href="../auto_examples/cluster/plot_face_ward_segmentation.html#sphx-glr-auto-examples-cluster-plot-face-ward-segmentation-py"><span class="std std-ref">raccoon face</span></a> 。</dd>
</dl>
<div class="topic">
<p class="topic-title first">示例:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_face_ward_segmentation.html#sphx-glr-auto-examples-cluster-plot-face-ward-segmentation-py"><span class="std std-ref">A demo of structured Ward hierarchical clustering on a raccoon face image</span></a>: Ward clustering
to split the image of a raccoon face in regions.</li>
<li><a class="reference internal" href="../auto_examples/cluster/plot_ward_structured_vs_unstructured.html#sphx-glr-auto-examples-cluster-plot-ward-structured-vs-unstructured-py"><span class="std std-ref">Hierarchical clustering: structured vs unstructured ward</span></a>: Example of
Ward algorithm on a swiss-roll, comparison of structured approaches
versus unstructured approaches.</li>
<li><a class="reference internal" href="../auto_examples/cluster/plot_feature_agglomeration_vs_univariate_selection.html#sphx-glr-auto-examples-cluster-plot-feature-agglomeration-vs-univariate-selection-py"><span class="std std-ref">Feature agglomeration vs. univariate selection</span></a>:
Example of dimensionality reduction with feature agglomeration based on
Ward hierarchical clustering.</li>
<li><a class="reference internal" href="../auto_examples/cluster/plot_agglomerative_clustering.html#sphx-glr-auto-examples-cluster-plot-agglomerative-clustering-py"><span class="std std-ref">Agglomerative clustering with and without structure</span></a></li>
</ul>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p><strong>Connectivity constraints with average and complete linkage</strong></p>
<p class="last">Connectivity constraints 和 complete or average linkage 可以增强 agglomerative clustering 中的
‘rich getting richer’ 现象。特别是，如果建立的是 <a class="reference internal" href="generated/sklearn.neighbors.kneighbors_graph.html#sklearn.neighbors.kneighbors_graph" title="sklearn.neighbors.kneighbors_graph"><code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.neighbors.kneighbors_graph</span></code></a>。
在少量聚类的限制中, 更倾向于给出一些 macroscopically occupied clusters 并且几乎是空的 (讨论内容请查看
<a class="reference internal" href="../auto_examples/cluster/plot_agglomerative_clustering.html#sphx-glr-auto-examples-cluster-plot-agglomerative-clustering-py"><span class="std std-ref">Agglomerative clustering with and without structure</span></a>)。</p>
</div>
<a class="reference external image-reference" href="../auto_examples/cluster/plot_agglomerative_clustering.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_agglomerative_clustering_001.png" src="modules/../auto_examples/cluster/images/sphx_glr_plot_agglomerative_clustering_001.png" /></a>
<a class="reference external image-reference" href="../auto_examples/cluster/plot_agglomerative_clustering.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_agglomerative_clustering_002.png" src="modules/../auto_examples/cluster/images/sphx_glr_plot_agglomerative_clustering_002.png" /></a>
<a class="reference external image-reference" href="../auto_examples/cluster/plot_agglomerative_clustering.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_agglomerative_clustering_003.png" src="modules/../auto_examples/cluster/images/sphx_glr_plot_agglomerative_clustering_003.png" /></a>
<a class="reference external image-reference" href="../auto_examples/cluster/plot_agglomerative_clustering.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_agglomerative_clustering_004.png" src="modules/../auto_examples/cluster/images/sphx_glr_plot_agglomerative_clustering_004.png" /></a>
</div>
<div class="section" id="varying-the-metric">
<h3>2.3.6.3. Varying the metric<a class="headerlink" href="#varying-the-metric" title="Permalink to this headline">¶</a></h3>
<p>Average and complete linkage 可以使用各种距离 (or affinities), 特别是 Euclidean distance (<em>l2</em>),
Manhattan distance（曼哈顿距离）(or Cityblock（城市区块距离）, or <em>l1</em>), cosine distance(余弦距离),</p>
<blockquote>
<div>或者任何预先计算的 affinity matrix（亲和度矩阵）.</div></blockquote>
<ul class="simple">
<li><em>l1</em> distance 有利于稀疏特征或者稀疏噪声: 例如很多特征都是0，就想在文本挖掘中使用 rare words 一样。</li>
<li><em>cosine</em> distance 非常有趣因为它对全局放缩是一样的。</li>
</ul>
<p>选择度量标准的方针是使得不同类样本之间距离最大化，并且最小化同类样本之间的距离。</p>
<a class="reference external image-reference" href="../auto_examples/cluster/plot_agglomerative_clustering_metrics.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_agglomerative_clustering_metrics_005.png" src="modules/../auto_examples/cluster/images/sphx_glr_plot_agglomerative_clustering_metrics_005.png" /></a>
<a class="reference external image-reference" href="../auto_examples/cluster/plot_agglomerative_clustering_metrics.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_agglomerative_clustering_metrics_006.png" src="modules/../auto_examples/cluster/images/sphx_glr_plot_agglomerative_clustering_metrics_006.png" /></a>
<a class="reference external image-reference" href="../auto_examples/cluster/plot_agglomerative_clustering_metrics.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_agglomerative_clustering_metrics_007.png" src="modules/../auto_examples/cluster/images/sphx_glr_plot_agglomerative_clustering_metrics_007.png" /></a>
<div class="topic">
<p class="topic-title first">示例:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_agglomerative_clustering_metrics.html#sphx-glr-auto-examples-cluster-plot-agglomerative-clustering-metrics-py"><span class="std std-ref">Agglomerative clustering with different metrics</span></a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="dbscan">
<span id="id15"></span><h2>2.3.7. DBSCAN<a class="headerlink" href="#dbscan" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="generated/sklearn.cluster.DBSCAN.html#sklearn.cluster.DBSCAN" title="sklearn.cluster.DBSCAN"><code class="xref py py-class docutils literal notranslate"><span class="pre">DBSCAN</span></code></a> 算法将聚类视为被低密度区域分隔的高密度区域。由于这个相当普遍的观点，
DBSCAN发现的聚类可以是任何形状的，与假设聚类是 convex shaped 的 K-means 相反。
DBSCAN 的核心概念是 <em>core samples</em>, 是指位于高密度区域的样本。
因此一个聚类是一组核心样本，每个核心样本彼此靠近（通过一定距离度量测量）
和一组接近核心样本的非核心样本（但本身不是核心样本）。算法中的两个参数, <code class="docutils literal notranslate"><span class="pre">min_samples</span></code>
和 <code class="docutils literal notranslate"><span class="pre">eps</span></code>,正式的定义了我们所说的 <a href="#id16"><span class="problematic" id="id17">*</span></a>dense*（稠密）。较高的 <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> 或者</p>
<blockquote>
<div>较低的 <a href="#id18"><span class="problematic" id="id19">``</span></a>eps``表示形成聚类所需的较高密度。</div></blockquote>
<p>更正式的,我们定义核心样本是指数据集中的一个样本，存在 <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> 个其他样本在 <code class="docutils literal notranslate"><span class="pre">eps</span></code>
距离范围内，这些样本被定为为核心样本的邻居 <em>neighbors</em> 。这告诉我们核心样本在向量空间稠密的区域。
一个聚类是一个核心样本的集合，可以通过递归来构建，选取一个核心样本，查找它所有的 neighbors （邻居样本）
中的核心样本，然后查找 <em>their</em> （新获取的核心样本）的 neighbors （邻居样本）中的核心样本，递归这个过程。
聚类中还具有一组非核心样本，它们是集群中核心样本的邻居的样本，但本身并不是核心样本。
显然，这些样本位于聚类的边缘。</p>
<dl class="docutils">
<dt>根据定义，任何核心样本都是聚类的一部分，任何不是核心样本并且和任意一个核心样本距离都大于</dt>
<dd><code class="docutils literal notranslate"><span class="pre">eps</span></code> 的样本将被视为异常值。</dd>
</dl>
<p>在下图中，颜色表示聚类成员属性，大圆圈表示算法发现的核心样本。 较小的圈子是仍然是群集的
一部分的非核心样本。 此外，异常值由下面的黑点表示。</p>
<p class="centered">
<strong><a class="reference external" href="../auto_examples/cluster/plot_dbscan.html"><img alt="dbscan_results" src="modules/../auto_examples/cluster/images/sphx_glr_plot_dbscan_001.png" /></a></strong></p><div class="topic">
<p class="topic-title first">示例:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_dbscan.html#sphx-glr-auto-examples-cluster-plot-dbscan-py"><span class="std std-ref">Demo of DBSCAN clustering algorithm</span></a></li>
</ul>
</div>
<div class="topic">
<p class="topic-title first">实现</p>
<p>DBSCAN 算法是具有确定性的，当以相同的顺序给出相同的数据时总是形成相同的聚类。
然而，当以不同的顺序提供数据时聚类的结果可能不相同。首先，即使核心样本总是被
分配给相同的聚类，这些集群的标签将取决于数据中遇到这些样本的顺序。第二个更重
要的是，非核心样本的聚类可能因数据顺序而有所不同。
当一个非核心样本距离两个核心样本的距离都小于 <code class="docutils literal notranslate"><span class="pre">eps</span></code> 时，就会发生这种情况。
通过三角不等式可知，这两个核心样本距离一定大于 <code class="docutils literal notranslate"><span class="pre">eps</span></code> 或者处于同一个聚类中。
非核心样本将被非配到首先查找到改样本的类别，因此结果将取决于数据的顺序。</p>
<p>当前版本使用 ball trees 和 kd-trees 来确定领域，这样避免了计算全部的距离矩阵
（0.14 之前的 scikit-learn 版本计算全部的距离矩阵）。保留使用 custom metrics
（自定义指标）的可能性。细节请参照 <code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighbors</span></code>。</p>
</div>
<div class="topic">
<p class="topic-title first">大量样本的内存消耗</p>
<p>默认的实现方式并没有充分利用内存，因为在不使用 kd-trees 或者 ball-trees 的情况下构建一个
完整的相似度矩阵（e.g. 使用稀疏矩阵）。这个矩阵将消耗 n^2 个浮点数。
解决这个问题的几种机制:</p>
<ul>
<li><p class="first">A sparse radius neighborhood graph （稀疏半径邻域图）(其中缺少条目被假定为距离超出eps)
可以以高效的方式预先编译，并且可以使用 <code class="docutils literal notranslate"><span class="pre">metric='precomputed'</span></code> 来运行 dbscan。</p>
</li>
<li><p class="first">数据可以压缩，当数据中存在准确的重复时，可以删除这些重复的数据，或者使用BIRCH。
任何。然后仅需要使用相对少量的样本来表示大量的点。当训练DBSCAN时，可以提供一个</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">sample_weight</span></code> 参数。</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="topic">
<p class="topic-title first">引用:</p>
<ul class="simple">
<li>“A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases
with Noise”
Ester, M., H. P. Kriegel, J. Sander, and X. Xu,
In Proceedings of the 2nd International Conference on Knowledge Discovery
and Data Mining, Portland, OR, AAAI Press, pp. 226–231. 1996</li>
</ul>
</div>
</div>
<div class="section" id="birch">
<span id="id20"></span><h2>2.3.8. Birch<a class="headerlink" href="#birch" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="generated/sklearn.cluster.Birch.html#sklearn.cluster.Birch" title="sklearn.cluster.Birch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Birch</span></code></a> 为提供的数据构建一颗 Characteristic Feature Tree (CFT，聚类特征树)。
数据实质上是被有损压缩成一组 Characteristic Feature nodes (CF Nodes，聚类特征节点)。
CF Nodes 中有一部分子聚类被称为 Characteristic Feature subclusters (CF Subclusters)，
并且这些位于非终端位置的CF Subclusters 可以拥有 CF Nodes 作为孩子节点。</p>
<p>CF Subclusters 保存用于聚类的必要信息，防止将整个输入数据保存在内存中。
这些信息包括:</p>
<ul class="simple">
<li>Number of samples in a subcluster（子聚类中样本数）.</li>
<li>Linear Sum - A n-dimensional vector holding the sum of all samples（保存所有样本和的n维向量）</li>
<li>Squared Sum - Sum of the squared L2 norm of all samples（所有样本的L2 norm的平方和）.</li>
<li>Centroids - To avoid recalculation linear sum / n_samples（为了防止重复计算 linear sum / n_samples）.</li>
<li>Squared norm of the centroids（质心的 Squared norm ）.</li>
</ul>
<p>Birch 算法有两个参数，即 threshold （阈值）和 branching factor 分支因子。Branching factor （分支因子）
限制了一个节点中的子集群的数量 ，threshold （簇半径阈值）限制了新加入的样本和存在与现有子集群中样本的最大距离。</p>
<p>该算法可以视为将一个实例或者数据简化的方法，因为它将输入的数据简化到可以直接从CFT的叶子结点中获取的一组子聚类。
这种简化的数据可以通过将其馈送到global clusterer（全局聚类）来进一步处理。Global clusterer（全局聚类）可以
通过 <a href="#id21"><span class="problematic" id="id22">``</span></a>n_clusters``来设置。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">n_clusters</span></code> 被设置为 None，将直接读取叶子结点中的子聚类，否则，global clustering（全局聚类）
将逐步标记他的 subclusters 到 global clusters (labels) 中，样本将被映射到 距离最近的子聚类的global label中。</p>
<p><strong>算法描述:</strong></p>
<ul class="simple">
<li>一个新的样本作为一个CF Node 被插入到 CF Tree 的根节点。然后将其合并到根节点的子聚类中去，使得合并后子聚类
拥有最小的半径，子聚类的选取受 threshold 和 branching factor 的约束。如果子聚类也拥有孩子节点，则重复执
行这个步骤直到到达叶子结点。在叶子结点中找到最近的子聚类以后，递归的更新这个子聚类及其父聚类的属性。</li>
<li>如果合并了新样本和最近的子聚类获得的子聚类半径大约square of the threshold（阈值的平方），
并且子聚类的数量大于branching factor（分支因子），则将为这个样本分配一个临时空间。
最远的两个子聚类被选取，剩下的子聚类按照之间的距离分为两组作为被选取的两个子聚类的孩子节点。</li>
<li>If this split node has a parent subcluster and there is room
for a new subcluster, then the parent is split into two. If there is no room,
then this node is again split into two and the process is continued
recursively, till it reaches the root.
如果拆分的节点有一个 parent subcluster ，并且有一个容纳一个新的子聚类的空间，那么父聚类拆分成两个。
如果没有空间容纳一个新的聚类，那么这个节点将被再次拆分，依次向上检查父节点是否需要分裂，
如果需要按叶子节点方式相同分裂。</li>
</ul>
<p><strong>Birch or MiniBatchKMeans?</strong></p>
<blockquote>
<div><ul class="simple">
<li>Birch 在高维数据上表现不好。一条经验法则，如果 <code class="docutils literal notranslate"><span class="pre">n_features</span></code> 大于20，通常使用 MiniBatchKMeans 更好。</li>
<li>如果需要减少数据实例的数量，或者如果需要大量的子聚类作为预处理步骤或者其他， Birch 比 MiniBatchKMeans 更有用。</li>
</ul>
</div></blockquote>
<p><strong>How to use partial_fit?</strong></p>
<p>为了避免对 global clustering 的计算，每次调用建议使用  <code class="docutils literal notranslate"><span class="pre">partial_fit</span></code> 。</p>
<blockquote>
<div><ol class="arabic simple">
<li>初始化 <code class="docutils literal notranslate"><span class="pre">n_clusters=None</span></code> 。</li>
<li>通过多次调用 partial_fit 训练所以的数据。</li>
<li>设置 <code class="docutils literal notranslate"><span class="pre">n_clusters</span></code> 为所需值，通过使用 <code class="docutils literal notranslate"><span class="pre">brc.set_params(n_clusters=n_clusters)</span></code> 。</li>
<li>最后不需要参数调用 <code class="docutils literal notranslate"><span class="pre">partial_fit</span></code> , 例如 <code class="docutils literal notranslate"><span class="pre">brc.partial_fit()</span></code> 执行全局聚类。</li>
</ol>
</div></blockquote>
<a class="reference external image-reference" href="../auto_examples/cluster/plot_birch_vs_minibatchkmeans.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_birch_vs_minibatchkmeans_001.png" src="modules/../auto_examples/cluster/images/sphx_glr_plot_birch_vs_minibatchkmeans_001.png" /></a>
<div class="topic">
<p class="topic-title first">参考:</p>
<ul class="simple">
<li>Tian Zhang, Raghu Ramakrishnan, Maron Livny
BIRCH: An efficient data clustering method for large databases.
<a class="reference external" href="http://www.cs.sfu.ca/CourseCentral/459/han/papers/zhang96.pdf">http://www.cs.sfu.ca/CourseCentral/459/han/papers/zhang96.pdf</a></li>
<li>Roberto Perdisci
JBirch - Java implementation of BIRCH clustering algorithm
<a class="reference external" href="https://code.google.com/archive/p/jbirch">https://code.google.com/archive/p/jbirch</a></li>
</ul>
</div>
</div>
<div class="section" id="clustering-evaluation">
<span id="id23"></span><h2>2.3.9. 聚类性能度量<a class="headerlink" href="#clustering-evaluation" title="Permalink to this headline">¶</a></h2>
<p>度量聚类算法的性能不是简单的统计错误的数量或计算监督分类算法中的 precision （准确率）和 recall （召回率）。
特别地，任何 evaluation metric （度量指标）不应该考虑到 cluster labels （簇标签）的绝对值，而是如果这个簇定义类似于某些 ground truth set of classes 或者满足某些假设，使得属于同一个类的成员更类似于根据某些 similarity metric （相似性度量）的不同类的成员。</p>
<div class="section" id="rand">
<span id="adjusted-rand-score"></span><h3>2.3.9.1. 调整后的 Rand 指数<a class="headerlink" href="#rand" title="Permalink to this headline">¶</a></h3>
<p>考虑到 the ground truth class 赋值 <code class="docutils literal notranslate"><span class="pre">labels_true</span></code> 和相同样本 <code class="docutils literal notranslate"><span class="pre">labels_pred</span></code> 的聚类算法分配的知识，<strong>adjusted Rand index</strong> 是一个函数，用于测量两个 assignments （任务）的 <strong>similarity（相似度）</strong> ，忽略 permutations （排列）和 <strong>with chance normalization（使用机会规范化）</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.24...</span>
</pre></div>
</div>
<p>可以在预测的标签中 permute （排列） 0 和 1，重命名为 2 到 3， 得到相同的分数:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.24...</span>
</pre></div>
</div>
<p>另外， <a class="reference internal" href="generated/sklearn.metrics.adjusted_rand_score.html#sklearn.metrics.adjusted_rand_score" title="sklearn.metrics.adjusted_rand_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">adjusted_rand_score</span></code></a> 是 <strong>symmetric（对称的）</strong> : 交换参数不会改变 score （得分）。它可以作为 <strong>consensus measure（共识度量）</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_pred</span><span class="p">,</span> <span class="n">labels_true</span><span class="p">)</span>  
<span class="go">0.24...</span>
</pre></div>
</div>
<p>完美的标签得分为 1.0</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="n">labels_true</span><span class="p">[:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>坏 (e.g. independent labelings（独立标签）) 有负数 或 接近于 0.0 分:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">-0.12...</span>
</pre></div>
</div>
<div class="section" id="id24">
<h4>2.3.9.1.1. 优点<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><strong>Random (uniform) label assignments have a ARI score close to 0.0（随机（统一）标签分配的 ARI 评分接近于 0.0）</strong>
对于 <code class="docutils literal notranslate"><span class="pre">n_clusters</span></code> 和 <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> 的任何值（这不是原始的 Rand index 或者 V-measure 的情况）。</li>
<li><strong>Bounded range（范围是有界的） [-1, 1]</strong>: negative values （负值）是坏的 (独立性标签), 类似的聚类有一个 positive ARI （正的 ARI）， 1.0 是完美的匹配得分。</li>
<li><strong>No assumption is made on the cluster structure（对簇的结构不需作出任何假设）</strong>: 可以用于比较聚类算法，例如 k-means，其假定 isotropic blob shapes 与可以找到具有 “folded” shapes 的聚类的 spectral clustering algorithms（谱聚类算法）的结果。</li>
</ul>
</div>
<div class="section" id="id25">
<h4>2.3.9.1.2. 缺点<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">与 inertia 相反，<strong>ARI requires knowledge of the ground truth classes（ARI 需要 ground truth classes 的相关知识）</strong> ，而在实践中几乎不可用，或者需要人工标注者手动分配（如在监督学习环境中）。</p>
<p>然而，ARI 还可以在 purely unsupervised setting （纯粹无监督的设置中）作为可用于 聚类模型选择（TODO）的共识索引的构建块。</p>
</li>
</ul>
<div class="topic">
<p class="topic-title first">示例:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_adjusted_for_chance_measures.html#sphx-glr-auto-examples-cluster-plot-adjusted-for-chance-measures-py"><span class="std std-ref">Adjustment for chance in clustering performance evaluation</span></a>: 分析数据集大小对随机分配聚类度量值的影响。</li>
</ul>
</div>
</div>
<div class="section" id="id26">
<h4>2.3.9.1.3. 数学表达<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h4>
<p>如果 C 是一个 ground truth class assignment（任务）， K 是簇的个数，我们定义 <span class="math">a</span> 和 <span class="math">b</span> 如:</p>
<ul class="simple">
<li><span class="math">a</span>, 在 C 中的相同集合的与 K 中的相同集合中的元素的对数</li>
<li><span class="math">b</span>, 在 C 中的不同集合与 K 中的不同集合中的元素的对数</li>
</ul>
<p>原始（未经调整）的 Rand index 则由下式给出:</p>
<div class="math">
<p><span class="math">\text{RI} = \frac{a + b}{C_2^{n_{samples}}}</span></p>
</div><p>其中 <span class="math">C_2^{n_{samples}}</span> 是数据集中可能的 pairs （数据对）的总数（不排序）。</p>
<p>然而，RI 评分不能保证 random label assignments （随机标签任务）将获得接近零的值（特别是如果簇的数量与采样数量相同的数量级）。</p>
<p>为了抵消这种影响，我们可以通过定义 adjusted Rand index （调整后的 Rand index）来 discount（折现） 随机标签的预期 RI <span class="math">E[\text{RI}]</span> ,如下所示:</p>
<div class="math">
<p><span class="math">\text{ARI} = \frac{\text{RI} - E[\text{RI}]}{\max(\text{RI}) - E[\text{RI}]}</span></p>
</div><div class="topic">
<p class="topic-title first">参考</p>
<ul class="simple">
<li><a class="reference external" href="http://link.springer.com/article/10.1007%2FBF01908075">Comparing Partitions</a>
L. Hubert and P. Arabie, Journal of Classification 1985</li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Rand_index#Adjusted_Rand_index">Wikipedia entry for the adjusted Rand index</a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="mutual-information">
<span id="mutual-info-score"></span><h3>2.3.9.2. 基于 Mutual Information （互信息）的分数<a class="headerlink" href="#mutual-information" title="Permalink to this headline">¶</a></h3>
<p>考虑到 ground truth class assignments （标定过的真实数据类分配） <code class="docutils literal notranslate"><span class="pre">labels_true</span></code> 的知识和相同样本 <code class="docutils literal notranslate"><span class="pre">labels_pred</span></code> 的聚类算法分配， <strong>Mutual Information</strong> 是测量两者 <strong>agreement</strong> 分配的函数，忽略 permutations（排列）。
这种测量方案的两个不同的标准化版本可用，<strong>Normalized Mutual Information(NMI)</strong> 和 <strong>Adjusted Mutual Information(AMI)</strong>。NMI 经常在文献中使用，而 AMI 最近被提出，并且 <strong>normalized against chance</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_mutual_info_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.22504...</span>
</pre></div>
</div>
<p>可以在 predicted labels （预测的标签）中 permute （排列） 0 和 1, 重命名为 2 到 3 并得到相同的得分:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_mutual_info_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.22504...</span>
</pre></div>
</div>
<p>全部的，<a class="reference internal" href="generated/sklearn.metrics.mutual_info_score.html#sklearn.metrics.mutual_info_score" title="sklearn.metrics.mutual_info_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">mutual_info_score</span></code></a>, <a class="reference internal" href="generated/sklearn.metrics.adjusted_mutual_info_score.html#sklearn.metrics.adjusted_mutual_info_score" title="sklearn.metrics.adjusted_mutual_info_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">adjusted_mutual_info_score</span></code></a> 和 <a class="reference internal" href="generated/sklearn.metrics.normalized_mutual_info_score.html#sklearn.metrics.normalized_mutual_info_score" title="sklearn.metrics.normalized_mutual_info_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">normalized_mutual_info_score</span></code></a> 是 symmetric（对称的）: 交换参数不会更改分数。因此，它们可以用作 <strong>consensus measure</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_mutual_info_score</span><span class="p">(</span><span class="n">labels_pred</span><span class="p">,</span> <span class="n">labels_true</span><span class="p">)</span>  
<span class="go">0.22504...</span>
</pre></div>
</div>
<p>完美标签得分是 1.0:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="n">labels_true</span><span class="p">[:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_mutual_info_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>
<span class="go">1.0</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">normalized_mutual_info_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>这对于 <code class="docutils literal notranslate"><span class="pre">mutual_info_score</span></code> 是不正确的，因此更难判断:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">mutual_info_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.69...</span>
</pre></div>
</div>
<p>坏的 (例如 independent labelings（独立标签）) 具有非正分数:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_mutual_info_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">-0.10526...</span>
</pre></div>
</div>
<div class="section" id="id27">
<h4>2.3.9.2.1. 优点<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><strong>Random (uniform) label assignments have a AMI score close to 0.0（随机（统一）标签分配的AMI评分接近0.0）</strong>
对于 <code class="docutils literal notranslate"><span class="pre">n_clusters</span></code> 和 <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> 的任何值（这不是原始 Mutual Information 或者 V-measure 的情况）。</li>
<li><strong>Bounded range（有界范围） [0, 1]</strong>:  接近 0 的值表示两个主要独立的标签分配，而接近 1 的值表示重要的一致性。此外，正好 0 的值表示 <strong>purely（纯粹）</strong> 独立标签分配，正好为 1 的 AMI 表示两个标签分配相等（有或者没有 permutation）。</li>
<li><strong>No assumption is made on the cluster structure（对簇的结构没有作出任何假设）</strong>: 可以用于比较聚类算法，例如 k-means，其假定 isotropic blob shapes 与可以找到具有 “folded” shapes 的聚类的 spectral clustering algorithms （频谱聚类算法）的结果。</li>
</ul>
</div>
<div class="section" id="id28">
<h4>2.3.9.2.2. 缺点<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">与 inertia 相反，<strong>MI-based measures require the knowledge of the ground truth classes（MI-based measures 需要了解 ground truth classes）</strong> ，而在实践中几乎不可用，或者需要人工标注或手动分配（如在监督学习环境中）。</p>
<p>然而，基于 MI-based measures （基于 MI 的测量方式）也可用于纯无人监控的设置，作为可用于聚类模型选择的 Consensus Index （共识索引）的构建块。</p>
</li>
<li><p class="first">NMI 和 MI 没有调整机会。</p>
</li>
</ul>
<div class="topic">
<p class="topic-title first">示例:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_adjusted_for_chance_measures.html#sphx-glr-auto-examples-cluster-plot-adjusted-for-chance-measures-py"><span class="std std-ref">Adjustment for chance in clustering performance evaluation</span></a>: 分析数据集大小对随机分配聚类度量值的影响。 此示例还包括 Adjusted Rand Index。</li>
</ul>
</div>
</div>
<div class="section" id="id29">
<h4>2.3.9.2.3. 数学公式<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h4>
<p>假设两个标签分配（相同的 N 个对象），<span class="math">U</span> 和 <span class="math">V</span>。
它们的 entropy （熵）是一个 partition set （分区集合）的不确定性量，定义如下:</p>
<div class="math">
<p><span class="math">H(U) = - \sum_{i=1}^{|U|}P(i)\log(P(i))</span></p>
</div><p>其中 <span class="math">P(i) = |U_i| / N</span> 是从 <span class="math">U</span> 中随机选取的对象到类 <span class="math">U_i</span> 的概率。同样对于 <span class="math">V</span>:</p>
<div class="math">
<p><span class="math">H(V) = - \sum_{j=1}^{|V|}P'(j)\log(P'(j))</span></p>
</div><p>使用 <span class="math">P'(j) = |V_j| / N</span>. <span class="math">U</span> 和 <span class="math">V</span> 之间的 mutual information (MI) 由下式计算:</p>
<div class="math">
<p><span class="math">\text{MI}(U, V) = \sum_{i=1}^{|U|}\sum_{j=1}^{|V|}P(i, j)\log\left(\frac{P(i,j)}{P(i)P'(j)}\right)</span></p>
</div><p>其中 <span class="math">P(i, j) = |U_i \cap V_j| / N</span> 是随机选择的对象落入两个类的概率 <span class="math">U_i</span> 和 <span class="math">V_j</span> 。</p>
<p>也可以用设定的基数表达式表示:</p>
<div class="math">
<p><span class="math">\text{MI}(U, V) = \sum_{i=1}^{|U|} \sum_{j=1}^{|V|} \frac{|U_i \cap V_j|}{N}\log\left(\frac{N|U_i \cap V_j|}{|U_i||V_j|}\right)</span></p>
</div><p>normalized (归一化) mutual information 被定义为</p>
<div class="math">
<p><span class="math">\text{NMI}(U, V) = \frac{\text{MI}(U, V)}{\sqrt{H(U)H(V)}}</span></p>
</div><p>mutual information 的价值以及 normalized variant （标准化变量）的值不会因 chance （机会）而被调整，随着不同标签（clusters（簇））的数量的增加，不管标签分配之间的 “mutual information” 的实际数量如何，都会趋向于增加。</p>
<p>mutual information 的期望值可以用 Vinh, Epps 和 Bailey,(2009) 的以下公式来计算。在这个方程式中,
<span class="math">a_i = |U_i|</span> (<span class="math">U_i</span> 中元素的数量) 和
<span class="math">b_j = |V_j|</span> (<span class="math">V_j</span> 中元素的数量).</p>
<div class="math">
<p><span class="math">E[\text{MI}(U,V)]=\sum_{i=1}^|U| \sum_{j=1}^|V| \sum_{n_{ij}=(a_i+b_j-N)^+
}^{\min(a_i, b_j)} \frac{n_{ij}}{N}\log \left( \frac{ N.n_{ij}}{a_i b_j}\right)
\frac{a_i!b_j!(N-a_i)!(N-b_j)!}{N!n_{ij}!(a_i-n_{ij})!(b_j-n_{ij})!
(N-a_i-b_j+n_{ij})!}</span></p>
</div><p>使用期望值, 然后可以使用与 adjusted Rand index 相似的形式来计算调整后的 mutual information:</p>
<div class="math">
<p><span class="math">\text{AMI} = \frac{\text{MI} - E[\text{MI}]}{\max(H(U), H(V)) - E[\text{MI}]}</span></p>
</div><div class="topic">
<p class="topic-title first">参考</p>
<ul class="simple">
<li>Strehl, Alexander, and Joydeep Ghosh (2002). “Cluster ensembles – a
knowledge reuse framework for combining multiple partitions”. Journal of
Machine Learning Research 3: 583–617.
<a class="reference external" href="http://strehl.com/download/strehl-jmlr02.pdf">doi:10.1162/153244303321897735</a>.</li>
<li>Vinh, Epps, and Bailey, (2009). “Information theoretic measures
for clusterings comparison”. Proceedings of the 26th Annual International
Conference on Machine Learning - ICML ‘09.
<a class="reference external" href="https://dl.acm.org/citation.cfm?doid=1553374.1553511">doi:10.1145/1553374.1553511</a>.
ISBN 9781605585161.</li>
<li>Vinh, Epps, and Bailey, (2010). Information Theoretic Measures for
Clusterings Comparison: Variants, Properties, Normalization and
Correction for Chance, JMLR
<a class="reference external" href="http://jmlr.csail.mit.edu/papers/volume11/vinh10a/vinh10a.pdf">http://jmlr.csail.mit.edu/papers/volume11/vinh10a/vinh10a.pdf</a></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Mutual_Information">Wikipedia entry for the (normalized) Mutual Information</a></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Adjusted_Mutual_Information">Wikipedia entry for the Adjusted Mutual Information</a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="v-measure">
<span id="homogeneity-completeness"></span><h3>2.3.9.3. 同质性，完整性和 V-measure<a class="headerlink" href="#v-measure" title="Permalink to this headline">¶</a></h3>
<p>鉴于样本的 ground truth class assignments （标定过的真实数据类分配）的知识，可以使用 conditional entropy （条件熵）分析来定义一些 intuitive metric（直观的度量）。</p>
<p>特别是 Rosenberg 和 Hirschberg (2007) 为任何 cluster （簇）分配定义了以下两个理想的目标:</p>
<ul class="simple">
<li><strong>homogeneity(同质性)</strong>: 每个簇只包含一个类的成员</li>
<li><strong>completeness(完整性)</strong>: 给定类的所有成员都分配给同一个簇。</li>
</ul>
<p>我们可以把这些概念作为分数 <a class="reference internal" href="generated/sklearn.metrics.homogeneity_score.html#sklearn.metrics.homogeneity_score" title="sklearn.metrics.homogeneity_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">homogeneity_score</span></code></a> 和 <a class="reference internal" href="generated/sklearn.metrics.completeness_score.html#sklearn.metrics.completeness_score" title="sklearn.metrics.completeness_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">completeness_score</span></code></a> 。两者均在 0.0 以上 和 1.0 以下（越高越好）:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">homogeneity_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.66...</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">completeness_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span> 
<span class="go">0.42...</span>
</pre></div>
</div>
<p>称为 <strong>V-measure</strong> 的 harmonic mean 由以下函数计算 <a class="reference internal" href="generated/sklearn.metrics.v_measure_score.html#sklearn.metrics.v_measure_score" title="sklearn.metrics.v_measure_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">v_measure_score</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">v_measure_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>    
<span class="go">0.51...</span>
</pre></div>
</div>
<p>V-measure 实际上等于上面讨论的 mutual information (NMI) 由 label entropies <a class="reference internal" href="#b2011" id="id30">[B2011]</a> （标准熵 <a class="reference internal" href="#b2011" id="id31">[B2011]</a>） 的总和 normalized （归一化）。</p>
<p>Homogeneity（同质性）, completeness（完整性） and V-measure 可以立即计算 <a class="reference internal" href="generated/sklearn.metrics.homogeneity_completeness_v_measure.html#sklearn.metrics.homogeneity_completeness_v_measure" title="sklearn.metrics.homogeneity_completeness_v_measure"><code class="xref py py-func docutils literal notranslate"><span class="pre">homogeneity_completeness_v_measure</span></code></a> 如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">homogeneity_completeness_v_measure</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>
<span class="gp">... </span>                                                     
<span class="go">(0.66..., 0.42..., 0.51...)</span>
</pre></div>
</div>
<p>以下聚类分配稍微好一些，因为它是同构但不完整的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">homogeneity_completeness_v_measure</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>
<span class="gp">... </span>                                                     
<span class="go">(1.0, 0.68..., 0.81...)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><a class="reference internal" href="generated/sklearn.metrics.v_measure_score.html#sklearn.metrics.v_measure_score" title="sklearn.metrics.v_measure_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">v_measure_score</span></code></a> 是 <strong>symmetric（对称的）</strong>: 它可以用于评估同一数据集上两个 independent assignments （独立赋值）的 <strong>agreement（协议）</strong>。</p>
<p>这不是这样的 <a class="reference internal" href="generated/sklearn.metrics.completeness_score.html#sklearn.metrics.completeness_score" title="sklearn.metrics.completeness_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">completeness_score</span></code></a> 和 <a class="reference internal" href="generated/sklearn.metrics.homogeneity_score.html#sklearn.metrics.homogeneity_score" title="sklearn.metrics.homogeneity_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">homogeneity_score</span></code></a>: 两者的关系是被这样约束着:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">homogeneity_score</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">completeness_score</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id32">
<h4>2.3.9.3.1. 优点<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><strong>Bounded scores（分数是有界的）</strong>: 0.0 是最坏的, 1.0 是一个完美的分数.</li>
<li>Intuitive interpretation（直观解释）: 具有不良 V-measure 的聚类可以在 <strong>qualitatively analyzed in terms of homogeneity and completeness（在同质性和完整性方面进行定性分析）</strong> 以更好地感知到作业完成的错误类型。</li>
<li><strong>No assumption is made on the cluster structure（对簇的结构没有作出任何假设）</strong>: 可以用于比较聚类算法，例如 k-means ，其假定 isotropic blob shapes 与可以找到具有 “folded” shapes 的聚类的 spectral clustering algorithms （频谱聚类算法）的结果。</li>
</ul>
</div>
<div class="section" id="id33">
<h4>2.3.9.3.2. 缺点<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">以前引入的 metrics （度量标准）**not normalized with regards to random labeling（并不是随机标记的标准化的）**: 这意味着，根据 number of samples （样本数量），clusters （簇）和 ground truth classes （标定过的真实数据类），完全随机的标签并不总是产生 homogeneity （同质性），completeness（完整性）和 hence v-measure 的相同值。特别是 <strong>random labeling won’t yield zero scores especially when the number of clusters is large（随机标记不会产生零分，特别是当集群数量大时）</strong>。</p>
<p>当样本数量超过 1000，簇的数量小于 10 时，可以安全地忽略此问题。<strong>For smaller sample sizes or larger number of clusters it is safer to use an adjusted index such as the Adjusted Rand Index (ARI)（对于较小的样本数量或者较大数量的簇，使用 adjusted index 例如 Adjusted Rand Index (ARI)）</strong>。</p>
</li>
</ul>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/cluster/plot_adjusted_for_chance_measures.html"><img alt="modules/../auto_examples/cluster/images/sphx_glr_plot_adjusted_for_chance_measures_001.png" src="modules/../auto_examples/cluster/images/sphx_glr_plot_adjusted_for_chance_measures_001.png" /></a>
</div>
<ul class="simple">
<li>这些 metrics （指标） <strong>require the knowledge of the ground truth classes（需要标定过的真实数据类的知识）</strong>，而在实践中几乎不可用，或需要人工标注来人工分配（如在受监督的学习环境中）。</li>
</ul>
<div class="topic">
<p class="topic-title first">示例:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_adjusted_for_chance_measures.html#sphx-glr-auto-examples-cluster-plot-adjusted-for-chance-measures-py"><span class="std std-ref">Adjustment for chance in clustering performance evaluation</span></a>: 分析数据集大小对随机分配聚类度量值的影响。</li>
</ul>
</div>
</div>
<div class="section" id="id34">
<h4>2.3.9.3.3. 数学表达<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h4>
<p>Homogeneity（同质性） 和 completeness（完整性） 的得分由下面公式给出:</p>
<div class="math">
<p><span class="math">h = 1 - \frac{H(C|K)}{H(C)}</span></p>
</div><div class="math">
<p><span class="math">c = 1 - \frac{H(K|C)}{H(K)}</span></p>
</div><p>其中 <span class="math">H(C|K)</span> 是 <strong>给定簇分配的类的 conditional entropy （条件熵）</strong> ，由下式给出:</p>
<div class="math">
<p><span class="math">H(C|K) = - \sum_{c=1}^{|C|} \sum_{k=1}^{|K|} \frac{n_{c,k}}{n}
\cdot \log\left(\frac{n_{c,k}}{n_k}\right)</span></p>
</div><p>并且 <span class="math">H(C)</span> 是 <strong>entropy of the classes（类的熵）</strong>，并且由下式给出:</p>
<div class="math">
<p><span class="math">H(C) = - \sum_{c=1}^{|C|} \frac{n_c}{n} \cdot \log\left(\frac{n_c}{n}\right)</span></p>
</div><p><span class="math">n</span> 个样本总数， <span class="math">n_c</span> 和 <span class="math">n_k</span> 分别属于 <span class="math">c</span> 类和簇 <span class="math">k</span> 的样本数，最后 <span class="math">n_{c,k}</span> 分配给簇 <span class="math">k</span> 的类 <span class="math">c</span> 的样本数。</p>
<p><strong>conditional entropy of clusters given class（给定类的条件熵）</strong> <span class="math">H(K|C)</span> 和 <strong>entropy of clusters（类的熵）</strong> <span class="math">H(K)</span> 以 symmetric manner （对称方式）定义。</p>
<p>Rosenberg 和 Hirschberg 进一步定义 <strong>V-measure</strong> 作为 <strong>harmonic mean of homogeneity and completeness（同质性和完整性的 harmonic mean）</strong>:</p>
<div class="math">
<p><span class="math">v = 2 \cdot \frac{h \cdot c}{h + c}</span></p>
</div><div class="topic">
<p class="topic-title first">参考</p>
<ul class="simple">
<li><a class="reference external" href="http://aclweb.org/anthology/D/D07/D07-1043.pdf">V-Measure: A conditional entropy-based external cluster evaluation
measure</a>
Andrew Rosenberg and Julia Hirschberg, 2007</li>
</ul>
<table class="docutils citation" frame="void" id="b2011" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[B2011]</td><td><em>(<a class="fn-backref" href="#id30">1</a>, <a class="fn-backref" href="#id31">2</a>)</em> <a class="reference external" href="http://www.cs.columbia.edu/~hila/hila-thesis-distributed.pdf">Identication and Characterization of Events in Social Media</a>, Hila
Becker, PhD Thesis.</td></tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="fowlkes-mallows">
<span id="fowlkes-mallows-scores"></span><h3>2.3.9.4. Fowlkes-Mallows 分数<a class="headerlink" href="#fowlkes-mallows" title="Permalink to this headline">¶</a></h3>
<p>当样本的已标定的真实数据的类别分配已知时，可以使用 Fowlkes-Mallows index （Fowlkes-Mallows 指数）(<a class="reference internal" href="generated/sklearn.metrics.fowlkes_mallows_score.html#sklearn.metrics.fowlkes_mallows_score" title="sklearn.metrics.fowlkes_mallows_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.metrics.fowlkes_mallows_score</span></code></a>) 。Fowlkes-Mallows 分数 FMI 被定义为 geometric mean of the pairwise precision （成对的准确率）和 recall （召回率）的几何平均值:</p>
<div class="math">
<p><span class="math">\text{FMI} = \frac{\text{TP}}{\sqrt{(\text{TP} + \text{FP}) (\text{TP} + \text{FN})}}</span></p>
</div><p>其中的 <code class="docutils literal notranslate"><span class="pre">TP</span></code> 是 <strong>True Positive（真正例）</strong> 的数量（即，真实标签和预测标签中属于相同簇的点对数），<code class="docutils literal notranslate"><span class="pre">FP</span></code> 是 <strong>False Positive（假正例）</strong> （即，在真实标签中属于同一簇的点对数，而不在预测标签中），<code class="docutils literal notranslate"><span class="pre">FN</span></code> 是 <strong>False Negative（假负例）</strong> 的数量（即，预测标签中属于同一簇的点对数，而不在真实标签中）。</p>
<p>score （分数）范围为 0 到 1。较高的值表示两个簇之间的良好相似性。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">fowlkes_mallows_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  <span class="c1"># doctest: +ELLIPSIS</span>
<span class="go">0.47140...</span>
</pre></div>
</div>
<p>可以在 predicted labels （预测的标签）中 permute （排列） 0 和 1 ，重命名为 2 到 3 并得到相同的得分:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">fowlkes_mallows_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.47140...</span>
</pre></div>
</div>
<p>完美的标签得分是 1.0:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="n">labels_true</span><span class="p">[:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">fowlkes_mallows_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">1.0</span>
</pre></div>
</div>
<p>坏的（例如 independent labelings （独立标签））的标签得分为 0:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">fowlkes_mallows_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.0</span>
</pre></div>
</div>
<div class="section" id="id35">
<h4>2.3.9.4.1. 优点<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><strong>Random (uniform) label assignments have a FMI score close to 0.0（随机（统一）标签分配 FMI 得分接近于 0.0）</strong> 对于 <code class="docutils literal notranslate"><span class="pre">n_clusters</span></code> 和 <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> 的任何值（对于原始 Mutual Information 或例如 V-measure 而言）。</li>
<li><strong>Bounded range（有界范围） [0, 1]</strong>:  接近于 0 的值表示两个标签分配在很大程度上是独立的，而接近于 1 的值表示 significant agreement 。此外，正好为 0 的值表示 <strong>purely</strong> 独立标签分配，正好为 1 的 AMI 表示两个标签分配相等（有或者没有 permutation （排列））。</li>
<li><strong>No assumption is made on the cluster structure（对簇的结构没有作出任何假设）</strong>: 可以用于比较诸如 k-means 的聚类算法，其将假设 isotropic blob shapes 与能够找到具有 “folded” shapes 的簇的 spectral clustering algorithms （频谱聚类算法）的结果相结合。</li>
</ul>
</div>
<div class="section" id="id36">
<h4>2.3.9.4.2. 缺点<a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>与 inertia（习惯）相反，<strong>FMI-based measures require the knowledge of the ground truth classes（基于 FMI 的测量方案需要了解已标注的真是数据的类）</strong> ，而几乎不用于实践和需要人工标注者的手动任务（如在监督学习的学习环境中）。</li>
</ul>
<div class="topic">
<p class="topic-title first">参考</p>
<ul class="simple">
<li>E. B. Fowkles and C. L. Mallows, 1983. “A method for comparing two
hierarchical clusterings”. Journal of the American Statistical Association.
<a class="reference external" href="http://wildfire.stat.ucla.edu/pdflibrary/fowlkes.pdf">http://wildfire.stat.ucla.edu/pdflibrary/fowlkes.pdf</a></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Fowlkes-Mallows_index">Wikipedia entry for the Fowlkes-Mallows Index</a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="silhouette">
<span id="silhouette-coefficient"></span><h3>2.3.9.5. Silhouette 系数<a class="headerlink" href="#silhouette" title="Permalink to this headline">¶</a></h3>
<p>如果标注过的真实数据的标签不知道，则必须使用模型本身进行度量。Silhouette Coefficient (<a class="reference internal" href="generated/sklearn.metrics.silhouette_score.html#sklearn.metrics.silhouette_score" title="sklearn.metrics.silhouette_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.metrics.silhouette_score</span></code></a>) 是一个这样的评估的例子，其中较高的 Silhouette Coefficient 得分与具有更好定义的聚类的模型相关。Silhouette Coefficient 是为每个样本定义的，由两个得分组成:</p>
<ul class="simple">
<li><strong>a</strong>: 样本与同一类别中所有其他点之间的平均距离。</li>
<li><strong>b</strong>: 样本与 <em>下一个距离最近的簇</em> 中的所有其他点之间的平均距离。</li>
</ul>
<p>然后将单个样本的 Silhouette 系数 <em>s</em> 给出为:</p>
<div class="math">
<p><span class="math">s = \frac{b - a}{max(a, b)}</span></p>
</div><p>给定一组样本的 Silhouette 系数作为每个样本的 Silhouette 系数的平均值。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">pairwise_distances</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">load_iris</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">target</span>
</pre></div>
</div>
<p>在正常使用情况下，将 Silhouette 系数应用于聚类分析的结果。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="k">import</span> <span class="n">KMeans</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kmeans_model</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">kmeans_model</span><span class="o">.</span><span class="n">labels_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">silhouette_score</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
<span class="gp">... </span>                                                     <span class="c1"># doctest: +ELLIPSIS</span>
<span class="go">0.55...</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">参考</p>
<ul class="simple">
<li>Peter J. Rousseeuw (1987). “Silhouettes: a Graphical Aid to the
Interpretation and Validation of Cluster Analysis”. Computational
and Applied Mathematics 20: 53–65.
<a class="reference external" href="http://dx.doi.org/10.1016/0377-0427(87)90125-7">doi:10.1016/0377-0427(87)90125-7</a>.</li>
</ul>
</div>
<div class="section" id="id37">
<h4>2.3.9.5.1. 优点<a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>对于不正确的 clustering （聚类），分数为 -1 ， highly dense clustering （高密度聚类）为 +1 。零点附近的分数表示 overlapping clusters （重叠的聚类）。</li>
<li>当 clusters （簇）密集且分离较好时，分数更高，这与 cluster （簇）的标准概念有关。</li>
</ul>
</div>
<div class="section" id="id38">
<h4>2.3.9.5.2. 缺点<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>convex clusters（凸的簇）的 Silhouette Coefficient 通常比其他类型的 cluster （簇）更高，例如通过 DBSCAN 获得的基于密度的 cluster（簇）。</li>
</ul>
<div class="topic">
<p class="topic-title first">示例:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_kmeans_silhouette_analysis.html#sphx-glr-auto-examples-cluster-plot-kmeans-silhouette-analysis-py"><span class="std std-ref">Selecting the number of clusters with silhouette analysis on KMeans clustering</span></a> : 在这个例子中，silhouette 分析用于为 n_clusters 选择最佳值.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="calinski-harabaz">
<span id="calinski-harabaz-index"></span><h3>2.3.9.6. Calinski-Harabaz 指数<a class="headerlink" href="#calinski-harabaz" title="Permalink to this headline">¶</a></h3>
<p>如果不知道真实数据的类别标签，则可以使用 Calinski-Harabaz 指数 (<a class="reference internal" href="generated/sklearn.metrics.calinski_harabaz_score.html#sklearn.metrics.calinski_harabaz_score" title="sklearn.metrics.calinski_harabaz_score"><code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.metrics.calinski_harabaz_score</span></code></a>) 来评估模型，其中较高的 Calinski-Harabaz 的得分与具有更好定义的聚类的模型相关。</p>
<p>对于 <span class="math">k</span> 簇，Calinski-Harabaz 得分 <span class="math">s</span> 是作为 between-clusters dispersion mean （簇间色散平均值）与 within-cluster dispersion（群内色散之间）的比值给出的:</p>
<div class="math">
<p><span class="math">s(k) = \frac{\mathrm{Tr}(B_k)}{\mathrm{Tr}(W_k)} \times \frac{N - k}{k - 1}</span></p>
</div><p>其中 <span class="math">B_K</span> 是 between group dispersion matrix （组间色散矩阵）， <span class="math">W_K</span> 是由以下定义的 within-cluster dispersion matrix （群内色散矩阵）:</p>
<div class="math">
<p><span class="math">W_k = \sum_{q=1}^k \sum_{x \in C_q} (x - c_q) (x - c_q)^T</span></p>
</div><div class="math">
<p><span class="math">B_k = \sum_q n_q (c_q - c) (c_q - c)^T</span></p>
</div><p><span class="math">N</span> 为数据中的点数，<span class="math">C_q</span> 为 cluster （簇） <span class="math">q</span> 中的点集， <span class="math">c_q</span> 为 cluster（簇） <span class="math">q</span> 的中心， <span class="math">c</span> 为 <span class="math">E</span> 的中心， <span class="math">n_q</span> 为 cluster（簇） <span class="math">q</span> 中的点数。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">pairwise_distances</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">load_iris</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">target</span>
</pre></div>
</div>
<p>在正常使用情况下，将 Calinski-Harabaz index （Calinski-Harabaz 指数）应用于 cluster analysis （聚类分析）的结果。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="k">import</span> <span class="n">KMeans</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kmeans_model</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">kmeans_model</span><span class="o">.</span><span class="n">labels_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">calinski_harabaz_score</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>  <span class="c1"># doctest: +ELLIPSIS</span>
<span class="go">560.39...</span>
</pre></div>
</div>
<div class="section" id="id39">
<h4>2.3.9.6.1. 优点<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>当 cluster （簇）密集且分离较好时，分数更高，这与一个标准的 cluster（簇）有关。</li>
<li>得分计算很快</li>
</ul>
</div>
<div class="section" id="id40">
<h4>2.3.9.6.2. 缺点<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>凸的簇的 Calinski-Harabaz index（Calinski-Harabaz 指数）通常高于其他类型的 cluster（簇），例如通过 DBSCAN 获得的基于密度的 cluster（簇）。</li>
</ul>
<div class="topic">
<p class="topic-title first">参考</p>
<ul class="simple">
<li>Caliński, T., &amp; Harabasz, J. (1974). “A dendrite method for cluster
analysis”. Communications in Statistics-theory and Methods 3: 1-27.
<a class="reference external" href="http://dx.doi.org/10.1080/03610926.2011.560741">doi:10.1080/03610926.2011.560741</a>.</li>
</ul>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>

      <!-- 评论留言区代码 start -->
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNDAwMi8xMDU0MA==">
        <script type="text/javascript">
        (function(d, s) {
            var j, e = d.getElementsByTagName(s)[0];

            if (typeof LivereTower === 'function') { return; }

            j = d.createElement(s);
            j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
            j.async = true;

            e.parentNode.insertBefore(j, e);
        })(document, 'script');
        </script>
      </div>
      <!-- 评论留言区代码 end -->

    </div>

    <!-- 提 PR 时按原来文档的字母排序 -->

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    
    

    

    
    <!-- modules/clustering.html -->
    <div class="apachecn_doc_right">
      校验者: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/apachecn/scikit-learn-doc-zh">@花开无声</a><br/>
                 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/apachecn/scikit-learn-doc-zh">@小瑶</a><br/>
      翻译者: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/apachecn/scikit-learn-doc-zh">@小瑶</a><br/>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/apachecn/scikit-learn-doc-zh">@krokyin</a><br/> 
    </div>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

  </div>

  <div class="footer">
      &copy; 2007 - 2017, scikit-learn developers (BSD License).
    <a href="../_sources/modules/clustering.rst.txt" rel="nofollow">Show this page source</a>
  </div>
   <div class="rel">
  
  <div class="buttonPrevious">
    <a href="manifold.html">Previous
    </a>
  </div>
  <div class="buttonNext">
    <a href="biclustering.html">Next
    </a>
  </div>
  
   </div>

  <!-- google analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  
    ga('create', 'UA-102475051-5', 'auto');
    ga('send', 'pageview');
  
  </script>
  
  <!-- baidu tongji -->
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?9cbab13b4d28a9811ae1d2d2176dab66";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>

  <!-- baidu push -->
  <script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script>
  </body>
</html>
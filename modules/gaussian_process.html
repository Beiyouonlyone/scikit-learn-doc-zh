

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>1.7. 高斯过程 &#8212; scikit-learn 0.19.0 中文文档 - ApacheCN</title>
<!-- htmltitle is before nature.css - we use this hack to load bootstrap first -->
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="../_static/css/bootstrap.min.css" media="screen" />
<link rel="stylesheet" href="../_static/css/bootstrap-responsive.css"/>

    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="1.8. 交叉分解" href="cross_decomposition.html" />
    <link rel="prev" title="1.6. 最近邻" href="neighbors.html" />


<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<script src="../_static/js/bootstrap.min.js" type="text/javascript"></script>
<link rel="canonical" href="http://scikit-learn.org/stable/modules/gaussian_process.html" />

<script type="text/javascript">
  $("div.buttonNext, div.buttonPrevious").hover(
     function () {
         $(this).css('background-color', '#FF9C34');
     },
     function () {
         $(this).css('background-color', '#A7D6E2');
     }
  );
  function showMenu() {
    var topNav = document.getElementById("scikit-navbar");
    if (topNav.className === "navbar") {
        topNav.className += " responsive";
    } else {
        topNav.className = "navbar";
    }
  };
</script>

  </head><body>

<div class="header-wrapper">
  <div class="header">
      <p class="logo"><a href="../index.html">
          <img src="../_static/scikit-learn-logo-small.png" alt="Logo"/>
      </a>
      </p><div class="navbar" id="scikit-navbar">
          <ul>
              <li><a href="../index.html">首页</a></li>
              <li><a href="../install.html">安装</a></li>
              <li class="btn-li">
                <div class="btn-group">
                    <a href="../documentation.html">文档</a>
                    <a class="btn dropdown-toggle" data-toggle="dropdown">
                      <span class="caret"></span>
                    </a>
                    <ul class="dropdown-menu">
                      <li class="link-title">Scikit-learn 0.19</li>
                      <li><a href="../tutorial/index.html">教程</a></li>
                      <li><a href="../user_guide.html">用户指南</a></li>
                      <li><a href="classes.html">API</a></li>
                      <li><a href="../faq.html">FAQ</a></li>
                      <li><a href="../developers/contributing.html">贡献</a></li>
                      <li class="divider"></li>
                      <li><a href="http://scikit-learn.org/stable/documentation.html">Scikit-learn 0.19 (stable)</a></li>
                      <li><a href="http://scikit-learn.org/0.18/documentation.html">Scikit-learn 0.18</a></li>
                      <li><a href="http://scikit-learn.org/0.17/documentation.html">Scikit-learn 0.17</a></li>
                      <li><a href="../_downloads/scikit-learn-docs.pdf">PDF 文档</a></li>
                    </ul>
                </div>
              </li>
              <li><a href="../auto_examples/index.html">示例</a></li>
              <li><a href="../project-timeline.html">时光轴</a></li>
              <li class="btn-li">
                <div class="btn-group">
                    <a href="javascript:void(0)">项目相关</a>
                    <a class="btn dropdown-toggle" data-toggle="dropdown">
                      <span class="caret"></span>
                    </a>
                    <ul class="dropdown-menu">
                      <li><a href="../project-role.html">项目角色</a></li>
                      <li><a href="../project-check-progress.html">校验进度</a></li>
                      <li><a href="../project-translation-progress.html">翻译进度</a></li>
                      <li><a href="//github.com/apachecn/scikit-learn-doc-zh#%E8%B4%A1%E7%8C%AE%E8%80%85" target="_blank">贡献者</a></li>
                      <li class="divider"></li>
                      <li><a href="../project-timeline.html">时光轴</a></li>
                      <li class="divider"></li>
                      <li><a href="../project-reward.html">项目奖励</a></li>
                      <li class="divider"></li>
                      <li><a href="http://www.apachecn.org/organization/244.html" target="_blank">积分物品</a></li>
                      <li><a href="http://www.apachecn.org/organization/269.html" target="_blank">兑换记录</a></li>
                      <li class="divider"></li>
                      <li><a href="../project-feedback.html">建议反馈</a></li>
                      <li><a href="../project-communication-group.html">技术交流</a></li>
                    </ul>
                </div>
              </li>
              <li><a href="//github.com/apachecn/scikit-learn-doc-zh#%E8%B4%A1%E7%8C%AE%E8%80%85" target="_blank">贡献者</a></li>
              <li><a href="//github.com/apachecn/scikit-learn-doc-zh" target="_blank">GitHub</a></li>
          </ul>
          <a href="javascript:void(0);" onclick="showMenu()">
              <div class="nav-icon">
                  <div class="hamburger-line"></div>
                  <div class="hamburger-line"></div>
                  <div class="hamburger-line"></div>
              </div>
          </a>
          <div class="search_form">
              <div class="gcse-search" id="cse" style="width: 100%;"></div>
          </div>
      </div> <!-- end navbar --></div>
</div>


<!-- Github "fork me" ribbon -->
<a href="https://github.com/apachecn/scikit-learn-doc-zh">
<img class="fork-me"
     style="position: absolute; top: 0; right: 0; border: 0;"
     src="../_static/img/starme.png"
     alt="Star me on GitHub" />
</a>

<div class="content-wrapper">
  <div class="sphinxsidebar">
  <div class="sphinxsidebarwrapper">
      <div class="rel">
  
      <div class="rellink">
      <a href="neighbors.html"
      accesskey="P">Previous
      <br/>
      <span class="smallrellink">
      1.6. 最近邻
      </span>
          <span class="hiddenrellink">
          1.6. 最近邻
          </span>
      </a>
      </div>
          <div class="spacer">
          &nbsp;
          </div>
      <div class="rellink">
      <a href="cross_decomposition.html"
      accesskey="N">Next
      <br/>
      <span class="smallrellink">
      1.8. 交叉分解
      </span>
          <span class="hiddenrellink">
          1.8. 交叉分解
          </span>
      </a>
      </div>

  <!-- Ad a link to the 'up' page -->
      <div class="spacer">
      &nbsp;
      </div>
      <div class="rellink">
      <a href="../supervised_learning.html">
      Up
      <br/>
      <span class="smallrellink">
      1. 监督学习
      </span>
          <span class="hiddenrellink">
          1. 监督学习
          </span>
          
      </a>
      </div>
  </div>
  
    <p class="doc-version"><b>scikit-learn v0.19.0</b><br/>
    <a href="http://scikit-learn.org/stable/support.html#documentation-resources">Other versions</a></p>
  <p class="citing">Please <b><a href="../about.html#citing-scikit-learn" style="font-size: 110%;">cite us </a></b>if you use the software.</p>
  <ul>
<li><a class="reference internal" href="#">1.7. 高斯过程</a><ul>
<li><a class="reference internal" href="#gpr">1.7.1. 高斯过程回归（GPR）</a></li>
<li><a class="reference internal" href="#id4">1.7.2. GPR 示例</a><ul>
<li><a class="reference internal" href="#id5">1.7.2.1. 具有噪声级的 GPR 估计</a></li>
<li><a class="reference internal" href="#gpr-kernel-ridge-regression">1.7.2.2. GPR 和内核岭回归(Kernel Ridge Regression)的比较</a></li>
<li><a class="reference internal" href="#mauna-loa-co2-grr">1.7.2.3. Mauna Loa CO2 数据中的 GRR</a></li>
</ul>
</li>
<li><a class="reference internal" href="#gpc">1.7.3. 高斯过程分类（GPC）</a></li>
<li><a class="reference internal" href="#id7">1.7.4. GPC 示例</a><ul>
<li><a class="reference internal" href="#id8">1.7.4.1. GPC 概率预测</a></li>
<li><a class="reference internal" href="#gpc-xor">1.7.4.2. GPC 在 XOR 数据集上的举例说明</a></li>
<li><a class="reference internal" href="#iris-gpc">1.7.4.3. iris 数据集上的高斯过程分类（GPC）</a></li>
</ul>
</li>
<li><a class="reference internal" href="#gp-kernels">1.7.5. 高斯过程内核</a><ul>
<li><a class="reference internal" href="#api">1.7.5.1. 高斯过程内核 API</a></li>
<li><a class="reference internal" href="#id11">1.7.5.2. 基础内核</a></li>
<li><a class="reference internal" href="#id12">1.7.5.3. 内核操作</a></li>
<li><a class="reference internal" href="#id13">1.7.5.4. 径向基函数内核</a></li>
<li><a class="reference internal" href="#matern">1.7.5.5. Matérn 内核</a></li>
<li><a class="reference internal" href="#id15">1.7.5.6. 有理二次内核</a></li>
<li><a class="reference internal" href="#id16">1.7.5.7. 正弦平方内核</a></li>
<li><a class="reference internal" href="#id17">1.7.5.8. 点乘内核</a></li>
<li><a class="reference internal" href="#id18">1.7.5.9. 参考文献</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id19">1.7.6. 传统高斯过程</a><ul>
<li><a class="reference internal" href="#id20">1.7.6.1. 回归实例介绍</a></li>
<li><a class="reference internal" href="#id21">1.7.6.2. 噪声数据拟合</a></li>
<li><a class="reference internal" href="#id22">1.7.6.3. 数学形式</a><ul>
<li><a class="reference internal" href="#id23">1.7.6.3.1. 初始假设</a></li>
<li><a class="reference internal" href="#blup">1.7.6.3.2. 最佳线性无偏预测（BLUP）</a></li>
<li><a class="reference internal" href="#eblup">1.7.6.3.3. 经验最佳线性无偏估计（EBLUP）</a></li>
</ul>
</li>
<li><a class="reference internal" href="#correlation-models">1.7.6.4. 关联模型</a></li>
<li><a class="reference internal" href="#regression-models">1.7.6.5. 回归模型</a></li>
<li><a class="reference internal" href="#id26">1.7.6.6. 实现细节</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<input type="checkbox" id="nav-trigger" class="nav-trigger" checked />
<label for="nav-trigger"></label>




    <div class="content">
          
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="gaussian-process">
<span id="id1"></span><h1>1.7. 高斯过程<a class="headerlink" href="#gaussian-process" title="Permalink to this headline">¶</a></h1>
<p><strong>高斯过程 (GP)</strong> 是一种常用的监督学习方法，旨在解决*回归问题*和*概率分类问题*。</p>
<p>高斯过程模型的优点如下：</p>
<blockquote>
<div><ul>
<li><p class="first">预测内插了观察结果（至少对于正则核）。</p>
</li>
<li><dl class="first docutils">
<dt>预测结果是概率形式的（高斯形式的）。这样的话，</dt>
<dd><p class="first last">人们可以计算得到经验置信区间并且据此来判断是否需要修改（在线拟合，自适应）</p>
</dd>
</dl>
<p>在一些区域的预测值。</p>
</li>
<li><dl class="first docutils">
<dt>通用性: 可以指定不同的:ref:<cite>内核(kernels)&lt;gp_kernels&gt;</cite>。</dt>
<dd><p class="first last">虽然该函数提供了常用的内核，但是也可以指定自定义内核。</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>高斯过程模型的缺点包括：</p>
<blockquote>
<div><ul class="simple">
<li>它们不稀疏，例如，模型通常使用整个样本/特征信息来进行预测。</li>
<li>高维空间模型会失效，高维也就是指特征的数量超过几十个。</li>
</ul>
</div></blockquote>
<div class="section" id="gpr">
<span id="id2"></span><h2>1.7.1. 高斯过程回归（GPR）<a class="headerlink" href="#gpr" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="generated/sklearn.gaussian_process.GaussianProcessRegressor.html#sklearn.gaussian_process.GaussianProcessRegressor" title="sklearn.gaussian_process.GaussianProcessRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianProcessRegressor</span></code></a> 类实现了回归情况下的高斯过程(GP)模型。
为此，需要实现指定GP的先验。当参数 <code class="docutils literal notranslate"><span class="pre">normalize_y=False</span></code> 时，先验的均值
通常假定为常数或者零; 当 <code class="docutils literal notranslate"><span class="pre">normalize_y=True</span></code> 时，先验均值通常为训练数
据的均值。而先验的方差通过传递 <a class="reference internal" href="#gp-kernels"><span class="std std-ref">内核(kernel)</span></a> 对象来指定。通过
最大化基于传递 <code class="docutils literal notranslate"><span class="pre">optimizer</span></code> 的对数边缘似然估计(LML)，内核的超参可以在
GaussianProcessRegressor 类执行拟合过程中被优化。由于 LML 可能会存在多个
局部最优解，因此优化过程可以通过指定 <code class="docutils literal notranslate"><span class="pre">n_restarts_optimizer</span></code> 参数进行
多次重复。通过设置内核的超参初始值来进行第一次优化的运行。后续的运行
过程中超参值都是从合理范围值中随机选取的。如果需要保持初始化超参值，
那么需要把优化器设置为 <cite>None</cite> 。</p>
<p>目标变量中的噪声级别通过参数 <code class="docutils literal notranslate"><span class="pre">alpha</span></code> 来传递并指定，要么全局是常数要么是一个数据点。
请注意，适度的噪声水平也可以有助于处理拟合期间的数字问题，因为它被有效地实现为吉洪诺夫正则化(Tikhonov regularization)，
即通过将其添加到核心矩阵的对角线。明确指定噪声水平的替代方法是将 WhiteKernel 组件包含在内核中，
这可以从数据中估计全局噪声水平（见下面的示例）。</p>
<p>算法实现是基于 <a class="reference internal" href="#rw2006" id="id3">[RW2006]</a> 中的算法 2.1 。除了标准 scikit learn 估计器的 API 之外，
GaussianProcessRegressor 的作用还包括：</p>
<ul class="simple">
<li>允许预测，无需事先拟合（基于GP先验）</li>
<li>提供了一种额外的方法 <code class="docutils literal notranslate"><span class="pre">sample_y(X)</span></code> , 其评估
在给定输入处从 GPR （先验或后验）绘制的样本</li>
<li>公开了一种方法 <code class="docutils literal notranslate"><span class="pre">log_marginal_likelihood(theta)</span></code> ,
可以在外部使用其他方式选择超参数，例如通过马尔科夫链蒙特卡罗链(Markov chain Monte Carlo)。</li>
</ul>
</div>
<div class="section" id="id4">
<h2>1.7.2. GPR 示例<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id5">
<h3>1.7.2.1. 具有噪声级的 GPR 估计<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>该示例说明具有包含 WhiteKernel 的和核(sum-kernel)的 GPR 可以估计数据的噪声水平。
对数边缘似然（LML）景观的图示表明存在 LML 的两个局部最大值。</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_noisy.html"><img alt="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_noisy_000.png" src="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_noisy_000.png" /></a>
</div>
<p>第一个对应于具有高噪声电平和大长度尺度的模型，其解释数据中噪声的所有变化。</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_noisy.html"><img alt="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_noisy_001.png" src="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_noisy_001.png" /></a>
</div>
<p>第二个具有较小的噪声水平和较短的长度尺度，这解释了无噪声功能关系的大部分变化。
第二种模式有较高的可能性; 然而，根据超参数的初始值，基于梯度的优化也可能会收敛到高噪声解。
因此，对于不同的初始化，重复优化多次是很重要的。</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_noisy.html"><img alt="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_noisy_002.png" src="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_noisy_002.png" /></a>
</div>
</div>
<div class="section" id="gpr-kernel-ridge-regression">
<h3>1.7.2.2. GPR 和内核岭回归(Kernel Ridge Regression)的比较<a class="headerlink" href="#gpr-kernel-ridge-regression" title="Permalink to this headline">¶</a></h3>
<p>内核脊回归（KRR）和 GPR 通过内部使用 “kernel trick(内核技巧)” 来学习目标函数。
KRR学习由相应内核引起的空间中的线性函数，该空间对应于原始空间中的非线性函数。
基于平均误差损失与脊正弦化，选择内核空间中的线性函数。
GPR使用内核来定义先验分布在目标函数上的协方差，并使用观察到的训练数据来定义似然函数。
基于贝叶斯定理，定义了目标函数上的（高斯）后验分布，其平均值用于预测。</p>
<p>一个主要区别是，GPR 可以基于边际似然函数上的梯度上升选择内核的超参数，
而KRR需要在交叉验证的损失函数（均方误差损失）上执行网格搜索。
另一个区别是，GPR 学习目标函数的生成概率模型，因此可以提供有意义的置信区间和后验样本以及预测值，
而KRR仅提供预测。</p>
<p>下图说明了人造数据集上的两种方法，其中包括正弦目标函数和强噪声。
该图比较了基于 ExpSineSquared 内核的 KRR 和 GPR 的学习模型，适用于学习周期函数。
内核的超参数控制内核的平滑度（length_scale）和周期性（周期性）。
此外，数据的噪声水平由 GPR 通过内核中的另外的 WhiteKernel 组件和 KRR 的正则化参数 α 明确地学习。</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_compare_gpr_krr.html"><img alt="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_compare_gpr_krr_001.png" src="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_compare_gpr_krr_001.png" /></a>
</div>
<p>该图显示，两种方法都可以学习合理的目标函数模型。
GPR将函数的周期正确地识别为 <span class="math">2*\pi</span> （6.28），而 KRR 选择倍增的周期为 <span class="math">4*\pi</span> 。
此外，GPR 为 KRR 不可用的预测提供了合理的置信区间。
两种方法之间的主要区别是拟合和预测所需的时间：
原则上KRR的拟合速度较快，超参数优化的网格搜索与超参数（ “curse of dimensionality(维度诅咒)” ）呈指数级关系。
GPR中的参数的基于梯度的优化不受此指数缩放的影响，因此在具有三维超参数空间的该示例上相当快。
预测的时间是相似的; 然而，生成 GPR 预测分布的方差需要的时间比生成平均值要长。</p>
</div>
<div class="section" id="mauna-loa-co2-grr">
<h3>1.7.2.3. Mauna Loa CO2 数据中的 GRR<a class="headerlink" href="#mauna-loa-co2-grr" title="Permalink to this headline">¶</a></h3>
<p>该示例基于 [RW2006] 的第 5.4.3 节。
它演示了使用梯度上升的对数边缘似然性的复杂内核工程和超参数优化的示例。
数据包括在 1958 年至 1997 年间夏威夷 Mauna Loa 天文台收集的每月平均大气二氧
化碳浓度（以百万分之几（ppmv）计）。目的是将二氧化碳浓度建模为时间t的函数。</p>
<p>内核由几个术语组成，负责说明信号的不同属性：</p>
<ul class="simple">
<li>一个长期的，顺利的上升趋势是由一个 RBF 内核来解释的。
具有较大长度尺寸的RBF内核将使该分量平滑;
没有强制这种趋势正在上升，这给 GP 带来了这个选择。
具体的长度尺度和振幅是自由的超参数。</li>
<li>季节性因素，由定期的 ExpSineSquared 内核解释，固定周期为1年。
该周期分量的长度尺度控制其平滑度是一个自由参数。
为了使准确周期性的衰减，采用带有RBF内核的产品。
该RBF组件的长度尺寸控制衰减时间，并且是另一个自由参数。</li>
<li>较小的中期不规则性将由 RationalQuadratic 内核组件来解释，
RationalQuadratic 内核组件的长度尺度和 alpha 参数决定长度尺度的扩散性。
根据 [RW2006] ，这些不规则性可以更好地由 RationalQuadratic 来解释，
而不是 RBF 内核组件，这可能是因为它可以容纳几个长度尺度。</li>
<li>“noise(噪声)” 一词，由一个 RBF 内核贡献组成，它将解释相关的噪声分量，</li>
</ul>
<blockquote>
<div>如局部天气现象以及 WhiteKernel 对白噪声的贡献。
相对幅度和RBF的长度尺度是进一步的自由参数。</div></blockquote>
<p>在减去目标平均值后最大化对数边际似然率产生下列内核，其中LML为-83.214:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">34.4</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">RBF</span><span class="p">(</span><span class="n">length_scale</span><span class="o">=</span><span class="mf">41.8</span><span class="p">)</span>
<span class="o">+</span> <span class="mf">3.27</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">RBF</span><span class="p">(</span><span class="n">length_scale</span><span class="o">=</span><span class="mi">180</span><span class="p">)</span> <span class="o">*</span> <span class="n">ExpSineSquared</span><span class="p">(</span><span class="n">length_scale</span><span class="o">=</span><span class="mf">1.44</span><span class="p">,</span>
                                                   <span class="n">periodicity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">+</span> <span class="mf">0.446</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">RationalQuadratic</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">17.7</span><span class="p">,</span> <span class="n">length_scale</span><span class="o">=</span><span class="mf">0.957</span><span class="p">)</span>
<span class="o">+</span> <span class="mf">0.197</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">RBF</span><span class="p">(</span><span class="n">length_scale</span><span class="o">=</span><span class="mf">0.138</span><span class="p">)</span> <span class="o">+</span> <span class="n">WhiteKernel</span><span class="p">(</span><span class="n">noise_level</span><span class="o">=</span><span class="mf">0.0336</span><span class="p">)</span>
</pre></div>
</div>
<p>因此，大多数目标信号（34.4ppm）由长期上升趋势（长度为41.8年）解释。
周期分量的振幅为3.27ppm，衰减时间为180年，长度为1.44。
长时间的衰变时间表明我们在当地非常接近周期性的季节性成分。
相关噪声的幅度为0.197ppm，长度为0.138年，白噪声贡献为0.197ppm。
因此，整体噪声水平非常小，表明该模型可以很好地解释数据。
该图还显示，该模型直到2015年左右才能做出置信度比较高的预测</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_co2.html"><img alt="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_co2_001.png" src="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_co2_001.png" /></a>
</div>
</div>
</div>
<div class="section" id="gpc">
<span id="id6"></span><h2>1.7.3. 高斯过程分类（GPC）<a class="headerlink" href="#gpc" title="Permalink to this headline">¶</a></h2>
<p>所述 <a class="reference internal" href="generated/sklearn.gaussian_process.GaussianProcessClassifier.html#sklearn.gaussian_process.GaussianProcessClassifier" title="sklearn.gaussian_process.GaussianProcessClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianProcessClassifier</span></code></a> 器实现了用于分类目的的高斯过程（GP），当测试的预测采用类概率的形式，更能够用于概率分类。
GaussianProcessClassifier 在隐函数 <span class="math">f</span> 之前设置GP先验，然后通过链接函数进行压缩以获得概率分类。
隐函数 <span class="math">f</span> 因此就是所谓的干扰函数(nuisance function)，其值不能被观测到，并且自身不具有相关性。
其目的是允许模型的表达形式更加简便，并且 <span class="math">f</span> 在预测过程中被去除（整合）。
GaussianProcessClassifier 实现了逻辑链接函数，
对于该逻辑，积分不能在分析上计算，但在二进制情况下很容易近似。</p>
<p>与回归设置相反，即使设置了高斯过程先验，隐函数 <span class="math">f</span> 的后验也不符合高斯分布，
因为高斯似然不适用于离散类标签。相反，使用的是与逻辑链接函数（logit）对应的非高斯似然。
GaussianProcessClassifier 通过拉普拉斯近似(Laplace approximation)来估计非高斯后验分布。
更多详细信息，请参见 [RW2006] 的第 3 章。</p>
<p>GP先验平均值假定为零。先验的协方差是通过传递 <a class="reference internal" href="#gp-kernels"><span class="std std-ref">内核(kernel)</span></a> 对象来指定的。
在通过最大化基于传递的对数边缘似然（LML）的 GaussianProcessRegressor 拟合期间，
优化内核的超参数 <code class="docutils literal notranslate"><span class="pre">optimizer</span></code> 。由于LML可能具有多个局部最优值，
所以优化器可以通过指定重复启动 <code class="docutils literal notranslate"><span class="pre">n_restarts_optimizer</span></code> 。
第一次运行始终从内核的初始超参数值开始执行;
从已经从允许值的范围中随机选择超参数值来进行后续运行。
如果初始超参数需要保持固定，<cite>None</cite> 可以传递作为优化器。</p>
<p><a class="reference internal" href="generated/sklearn.gaussian_process.GaussianProcessClassifier.html#sklearn.gaussian_process.GaussianProcessClassifier" title="sklearn.gaussian_process.GaussianProcessClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianProcessClassifier</span></code></a> 通过执行基于OvR(one-versus-rest)或
OvO(one-versus-one )策略的训练和预测来支持多类分类。
在OvR(one-versus-rest)策略中，每个类都配有一个二进制高斯过程分类器，该类别被训练为将该类与其余类分开。
在 “one_vs_one” 中，对于每对类拟合一个二进制高斯过程分类器，这被训练为分离这两个类。
这些二进制预测因子的预测被组合成多类预测。更多详细信息，请参阅 <a class="reference internal" href="multiclass.html#multiclass"><span class="std std-ref">多类别分类</span></a> 。</p>
<p>在高斯过程分类的情况下，”one_vs_one” 策略可能在计算上更廉价，
因为它必须解决涉及整个训练集的每一个子集的许多问题，
而不是整个数据集的较少的问题。由于高斯过程分类与数据集的大小相互立方，这可能要快得多。
但是，请注意，”one_vs_one” 不支持预测概率估计，而只是简单的预测。
此外，请注意， <a class="reference internal" href="generated/sklearn.gaussian_process.GaussianProcessClassifier.html#sklearn.gaussian_process.GaussianProcessClassifier" title="sklearn.gaussian_process.GaussianProcessClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianProcessClassifier</span></code></a> 在内部还没有实现真正的多类 Laplace 近似，
但如上所述，在解决内部二进制分类任务的基础上，它们使用OvR或OvO的组合方法。</p>
</div>
<div class="section" id="id7">
<h2>1.7.4. GPC 示例<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id8">
<h3>1.7.4.1. GPC 概率预测<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>该示例说明了对于具有不同选项的超参数的RBF内核的GPC预测概率。
第一幅图显示GPC具有任意选择的超参数的预测概率，以及对应于最大LML（对数边缘似然）对应的超参数。</p>
<p>虽然通过优化LML选择的超参数具有相当大的LML，但是根据测试数据的对数损失，它们的表现更差。
该图显示，这是因为它们在阶级边界（这是好的）表现出类概率的急剧变化，
但预测概率接近0.5远离类边界（这是坏的）这种不良影响是由于GPC内部使用了拉普拉斯逼近。</p>
<p>第二幅图显示了内核超参数的不同选择的LML（对数边缘似然），突出了在第一幅图中使用的通过黑点（训练集）选择的两个超参数。</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpc.html"><img alt="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpc_000.png" src="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpc_000.png" /></a>
</div>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpc.html"><img alt="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpc_001.png" src="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpc_001.png" /></a>
</div>
</div>
<div class="section" id="gpc-xor">
<h3>1.7.4.2. GPC 在 XOR 数据集上的举例说明<a class="headerlink" href="#gpc-xor" title="Permalink to this headline">¶</a></h3>
<p>此示例说明了在XOR数据上的GPC。各向同性的核（ <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.RBF.html#sklearn.gaussian_process.kernels.RBF" title="sklearn.gaussian_process.kernels.RBF"><code class="xref py py-class docutils literal notranslate"><span class="pre">RBF</span></code></a> ）和非固定的核（ <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.DotProduct.html#sklearn.gaussian_process.kernels.DotProduct" title="sklearn.gaussian_process.kernels.DotProduct"><code class="xref py py-class docutils literal notranslate"><span class="pre">DotProduct</span></code></a> ）对比固定性。
在这个特定的数据集上， <cite>DotProduct</cite> 内核获得了更好的结果，因为类边界是线性的，与坐标轴重合。
然而，实际上，诸如 <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.RBF.html#sklearn.gaussian_process.kernels.RBF" title="sklearn.gaussian_process.kernels.RBF"><code class="xref py py-class docutils literal notranslate"><span class="pre">RBF</span></code></a> 这样的固定内核经常获得更好结果。</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpc_xor.html"><img alt="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpc_xor_001.png" src="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpc_xor_001.png" /></a>
</div>
</div>
<div class="section" id="iris-gpc">
<h3>1.7.4.3. iris 数据集上的高斯过程分类（GPC）<a class="headerlink" href="#iris-gpc" title="Permalink to this headline">¶</a></h3>
<p>该示例说明了用于鸢尾花数据集的二维版本上各向同性和各向异性 RBF 核的 GPC 的预测概率。
这说明了 GPC 对多类分类的适用性。
各向异性 RBF 内核通过为两个特征维度分配不同的长度尺度来获得稍高的 LML（对数边缘似然）。</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpc_iris.html"><img alt="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpc_iris_001.png" src="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpc_iris_001.png" /></a>
</div>
</div>
</div>
<div class="section" id="gp-kernels">
<span id="id9"></span><h2>1.7.5. 高斯过程内核<a class="headerlink" href="#gp-kernels" title="Permalink to this headline">¶</a></h2>
<p>内核（也可以叫做GPs上下文中的”协方差函数”）
是决定高斯过程（GP）先验和后验形状的关键组成部分。
它们通过定义两个数据点的“相似性”，并结合相似的
数据点应该具有相似的目标值的假设，对所学习的函数进行编码。
内核可以分为两类：固定内核，只取决于两个数据点的距离，
不依赖于它们的绝对值 <span class="math">k(x_i, x_j)= k(d(x_i, x_j))</span>
，因此它们对于输入空间中的转换是不变的；非固定的内核，取
决于数据点的具体值。固定内核可以进一步细分为各向同性和各向
异性内核，其中各向同性内核不会在输入空间中旋转。想要了解
更多细节，请参看 <a class="reference internal" href="#rw2006" id="id10">[RW2006]</a> 的第四章。</p>
<div class="section" id="api">
<h3>1.7.5.1. 高斯过程内核 API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Kernel.html#sklearn.gaussian_process.kernels.Kernel" title="sklearn.gaussian_process.kernels.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">Kernel</span></code></a> 主要是用来计算数据点之间的高斯过程协方差。
为此，内核中 <code class="docutils literal notranslate"><span class="pre">__call__</span></code> 方法会被调用。该方法可以用于计算
2d阵列X中所有数据点对的“自动协方差”，或二维阵列X的数据点
与二维阵列Y中的数据点的所有组合的“互协方差”。以下论断对于
所有内核k（除了 <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.WhiteKernel.html#sklearn.gaussian_process.kernels.WhiteKernel" title="sklearn.gaussian_process.kernels.WhiteKernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">WhiteKernel</span></code></a>）都是成立的：<code class="docutils literal notranslate"><span class="pre">k(X)</span> <span class="pre">==</span> <span class="pre">K(X,</span> <span class="pre">Y=X)</span></code>。
如果仅仅是自协方差的对角线元素被使用，那么内核的方法 <code class="docutils literal notranslate"><span class="pre">diag()</span></code> 将会被调用，
该方法比等价的调用 <code class="docutils literal notranslate"><span class="pre">__call__</span></code>: <code class="docutils literal notranslate"><span class="pre">np.diag(k(X,</span> <span class="pre">X))</span> <span class="pre">==</span> <span class="pre">k.diag(X)</span></code>
具有更高的计算效率。</p>
<p>内核通过超参数向量 <span class="math">\theta</span> 进行参数化。这些超参数可以
控制例如内核的长度或周期性（见下文）。通过设置 <code class="docutils literal notranslate"><span class="pre">__call__</span></code>
方法的参数 <code class="docutils literal notranslate"><span class="pre">eval_gradient=True</span></code> ，所有的内核支持计算解析
内核自协方差对于 <span class="math">\theta</span> 的解析梯度。该梯度被用来在
高斯过程中（不论是回归型还是分类型的）计算LML（对数边缘似然）函数
的梯度，进而被用来通过梯度下降的方法极大化LML（对数边缘似然）函数
从而确定 <span class="math">\theta</span> 的值。对于每个超参数，当对内核的实例
进行赋值时，初始值和边界值需要被指定。通过内核对象属性 <code class="docutils literal notranslate"><span class="pre">theta</span></code> ，
<span class="math">\theta</span> 的当前值可以被获取或者设置。更重要的是，
超参的边界值可以被内核属性 <code class="docutils literal notranslate"><span class="pre">bounds</span></code> 获取。需要注意的是，
以上两种属性值(theta和bounds)都会返回内部使用值的日志转换值，
这是因为这两种属性值通常更适合基于梯度的优化。每个超参数的
规范 <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Hyperparameter.html#sklearn.gaussian_process.kernels.Hyperparameter" title="sklearn.gaussian_process.kernels.Hyperparameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Hyperparameter</span></code></a> 以实例形式被存储在相应内核中。
请注意使用了以”x”命名的超参的内核必然具有self.x和self.x_bounds这两种属性。</p>
<p>所有内核的抽象基类为 <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Kernel.html#sklearn.gaussian_process.kernels.Kernel" title="sklearn.gaussian_process.kernels.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">Kernel</span></code></a> 。Kernel 基类实现了
一个相似的接口 <code class="xref py py-class docutils literal notranslate"><span class="pre">Estimator</span></code> ，提供了方法 <code class="docutils literal notranslate"><span class="pre">get_params()</span></code> ,
<code class="docutils literal notranslate"><span class="pre">set_params()</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">clone()</span></code> 。这也允许通过诸如
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code> 或者 <code class="xref py py-class docutils literal notranslate"><span class="pre">GridSearch</span></code> 之类的元估计来设置内核值。
需要注意的是，由于内核的嵌套结构（通过内核操作符，如下所见），
内核参数的名称可能会变得相对复杂些。通常来说，对于二元内核操作，
参数的左运算元以 <code class="docutils literal notranslate"><span class="pre">k1__</span></code> 为前缀，而右运算元以 <code class="docutils literal notranslate"><span class="pre">k2__</span></code> 为前缀。
一个额外的便利方法是 <code class="docutils literal notranslate"><span class="pre">clone_with_theta(theta)</span></code>，
该方法返回克隆版本的内核，但是设置超参数为 <code class="docutils literal notranslate"><span class="pre">theta</span></code>。
示例如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.gaussian_process.kernels</span> <span class="k">import</span> <span class="n">ConstantKernel</span><span class="p">,</span> <span class="n">RBF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">ConstantKernel</span><span class="p">(</span><span class="n">constant_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">constant_value_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">))</span> <span class="o">*</span> <span class="n">RBF</span><span class="p">(</span><span class="n">length_scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">length_scale_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">))</span> <span class="o">+</span> <span class="n">RBF</span><span class="p">(</span><span class="n">length_scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">length_scale_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">hyperparameter</span> <span class="ow">in</span> <span class="n">kernel</span><span class="o">.</span><span class="n">hyperparameters</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">hyperparameter</span><span class="p">)</span>
<span class="go">Hyperparameter(name=&#39;k1__k1__constant_value&#39;, value_type=&#39;numeric&#39;, bounds=array([[  0.,  10.]]), n_elements=1, fixed=False)</span>
<span class="go">Hyperparameter(name=&#39;k1__k2__length_scale&#39;, value_type=&#39;numeric&#39;, bounds=array([[  0.,  10.]]), n_elements=1, fixed=False)</span>
<span class="go">Hyperparameter(name=&#39;k2__length_scale&#39;, value_type=&#39;numeric&#39;, bounds=array([[  0.,  10.]]), n_elements=1, fixed=False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">params</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> : </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
<span class="go">k1 : 1**2 * RBF(length_scale=0.5)</span>
<span class="go">k1__k1 : 1**2</span>
<span class="go">k1__k1__constant_value : 1.0</span>
<span class="go">k1__k1__constant_value_bounds : (0.0, 10.0)</span>
<span class="go">k1__k2 : RBF(length_scale=0.5)</span>
<span class="go">k1__k2__length_scale : 0.5</span>
<span class="go">k1__k2__length_scale_bounds : (0.0, 10.0)</span>
<span class="go">k2 : RBF(length_scale=2)</span>
<span class="go">k2__length_scale : 2.0</span>
<span class="go">k2__length_scale_bounds : (0.0, 10.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>  <span class="c1"># Note: log-transformed</span>
<span class="go">[ 0.         -0.69314718  0.69314718]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>  <span class="c1"># Note: log-transformed</span>
<span class="go">[[       -inf  2.30258509]</span>
<span class="go"> [       -inf  2.30258509]</span>
<span class="go"> [       -inf  2.30258509]]</span>
</pre></div>
</div>
<p>所有的高斯过程内核操作都可以通过 <a class="reference internal" href="classes.html#module-sklearn.metrics.pairwise" title="sklearn.metrics.pairwise"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.metrics.pairwise</span></code></a> 来进行互操作，反之亦然。
<a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Kernel.html#sklearn.gaussian_process.kernels.Kernel" title="sklearn.gaussian_process.kernels.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">Kernel</span></code></a> 的子类实例可以通过 <code class="docutils literal notranslate"><span class="pre">metric</span></code> 参数传给 <a class="reference internal" href="classes.html#module-sklearn.metrics.pairwise" title="sklearn.metrics.pairwise"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.metrics.pairwise</span></code></a> 中的</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">pairwise_kernels</span></code> 。更重要的是，超参数的梯度不是分析的，而是数字，所有这些内核只支持</div></blockquote>
<p>各向同性距离。该参数 <code class="docutils literal notranslate"><span class="pre">gamma</span></code> 被认为是一个超参数，可以进行优化。其他内核参数在初始化时直接设置，
并保持固定。</p>
</div>
<div class="section" id="id11">
<h3>1.7.5.2. 基础内核<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.gaussian_process.kernels.ConstantKernel.html#sklearn.gaussian_process.kernels.ConstantKernel" title="sklearn.gaussian_process.kernels.ConstantKernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstantKernel</span></code></a> 内核类可以被用作 <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Product.html#sklearn.gaussian_process.kernels.Product" title="sklearn.gaussian_process.kernels.Product"><code class="xref py py-class docutils literal notranslate"><span class="pre">Product</span></code></a> 内核类的一部分，
在它可以对其他因子（内核）进行度量的场景下或者作为更改高斯过程均值的</p>
<blockquote>
<div><a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Sum.html#sklearn.gaussian_process.kernels.Sum" title="sklearn.gaussian_process.kernels.Sum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sum</span></code></a> 类的一部分。这取决于参数 <span class="math">constant\_value</span> 的设置。该方法定义为：</div></blockquote>
<div class="math">
<p><span class="math">k(x_i, x_j) = constant\_value \;\forall\; x_1, x_2</span></p>
</div><p><a class="reference internal" href="generated/sklearn.gaussian_process.kernels.WhiteKernel.html#sklearn.gaussian_process.kernels.WhiteKernel" title="sklearn.gaussian_process.kernels.WhiteKernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">WhiteKernel</span></code></a> 内核类的主要应用实例在于当解释信号的噪声部分时
可以作为内核集合的一部分。通过调节参数 <span class="math">noise\_level</span>，
该类可以用来估计噪声级别。具体如下所示：</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = noise\_level \text{ if } x_i == x_j \text{ else } 0</span></p>
</div></div>
<div class="section" id="id12">
<h3>1.7.5.3. 内核操作<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>内核操作是把1~2个基内核与新内核进行合并。内核类 <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Sum.html#sklearn.gaussian_process.kernels.Sum" title="sklearn.gaussian_process.kernels.Sum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sum</span></code></a> 通过
<span class="math">k_{sum}(X, Y) = k1(X, Y) + k2(X, Y)</span> 相加来合并 <span class="math">k1</span>
和 <span class="math">k2</span> 内核。内核类 <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Product.html#sklearn.gaussian_process.kernels.Product" title="sklearn.gaussian_process.kernels.Product"><code class="xref py py-class docutils literal notranslate"><span class="pre">Product</span></code></a> 通过
<span class="math">k_{product}(X, Y) = k1(X, Y) * k2(X, Y)</span> 把 <span class="math">k1</span>
和 <span class="math">k2</span> 内核进行合并。内核类 <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Exponentiation.html#sklearn.gaussian_process.kernels.Exponentiation" title="sklearn.gaussian_process.kernels.Exponentiation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exponentiation</span></code></a> 通过
<span class="math">k_{exp}(X, Y) = k(X, Y)^\text{exponent}</span> 把基内核与
常量参数 <span class="math">exponent</span> 进行合并。</p>
</div>
<div class="section" id="id13">
<h3>1.7.5.4. 径向基函数内核<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.gaussian_process.kernels.RBF.html#sklearn.gaussian_process.kernels.RBF" title="sklearn.gaussian_process.kernels.RBF"><code class="xref py py-class docutils literal notranslate"><span class="pre">RBF</span></code></a> 内核是一个固定内核，它也被称为“平方指数”内核。它通过定长的参数 <span class="math">l&gt;0</span>
来对内核进行参数化。该参数既可以是标量（内核的各向同性变体）或者与输入 <span class="math">x</span> （内核的各向异性变体）
具有相同数量的维度的向量。该内核可以被定义为：</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = \text{exp}\left(-\frac{1}{2} d(x_i / l, x_j / l)^2\right)</span></p>
</div><p>这个内核是无限可微的，这意味着这个内核作为协方差函数的 GP 具有所有阶数的均方差导数，
因此非常平滑。由RBF内核产生的GP的先验和后验示意图如下所示：</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_prior_posterior.html"><img alt="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_prior_posterior_000.png" src="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_prior_posterior_000.png" /></a>
</div>
</div>
<div class="section" id="matern">
<h3>1.7.5.5. Matérn 内核<a class="headerlink" href="#matern" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Matern.html#sklearn.gaussian_process.kernels.Matern" title="sklearn.gaussian_process.kernels.Matern"><code class="xref py py-class docutils literal notranslate"><span class="pre">Matern</span></code></a> 内核是一个固定内核，是 <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.RBF.html#sklearn.gaussian_process.kernels.RBF" title="sklearn.gaussian_process.kernels.RBF"><code class="xref py py-class docutils literal notranslate"><span class="pre">RBF</span></code></a> 内核的泛化。它有一个额外的参数 <span class="math">\nu</span>，
该参数控制结果函数的平滑程度。它由定长参数 <span class="math">l&gt;0</span> 来实现参数化。该参数既可以是标量
（内核的各向同性变体）或者与输入 <span class="math">x</span> （内核的各向异性变体）具有相同数量的维度的向量。
该内核可以被定义为：</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = \sigma^2\frac{1}{\Gamma(\nu)2^{\nu-1}}\Bigg(\gamma\sqrt{2\nu} d(x_i / l, x_j / l)\Bigg)^\nu K_\nu\Bigg(\gamma\sqrt{2\nu} d(x_i / l, x_j / l)\Bigg),</span></p>
</div><p>因为 <span class="math">\nu\rightarrow\infty</span> ，Matérn 内核收敛到 RBF 内核。
当 <span class="math">\nu = 1/2</span> 时，Matérn 内核变得与绝对指数内核相同时，即</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = \sigma^2 \exp \Bigg(-\gamma d(x_i / l, x_j / l) \Bigg) \quad \quad \nu= \tfrac{1}{2}</span></p>
</div><p>特别的，当 <span class="math">\nu = 3/2</span> 时：</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = \sigma^2 \Bigg(1 + \gamma \sqrt{3} d(x_i / l, x_j / l)\Bigg) \exp \Bigg(-\gamma \sqrt{3}d(x_i / l, x_j / l) \Bigg) \quad \quad \nu= \tfrac{3}{2}</span></p>
</div><p>和 <span class="math">\nu = 5/2</span> :</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = \sigma^2 \Bigg(1 + \gamma \sqrt{5}d(x_i / l, x_j / l) +\frac{5}{3} \gamma^2d(x_i / l, x_j / l)^2 \Bigg) \exp \Bigg(-\gamma \sqrt{5}d(x_i / l, x_j / l) \Bigg) \quad \quad \nu= \tfrac{5}{2}</span></p>
</div><p>是学习函数的常用选择，并且不是无限可微的（由 RBF 内核假定）
但是至少具有一阶( <span class="math">\nu = 3/2</span> )或者二阶( <span class="math">\nu = 5/2</span> )可微性。</p>
<p>通过 <span class="math">\nu</span> 灵活控制学习函数的平滑性可以更加适应真正的底层函数关联属性。
通过 Matérn 内核产生的高斯过程的先验和后验如下图所示：</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_prior_posterior.html"><img alt="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_prior_posterior_004.png" src="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_prior_posterior_004.png" /></a>
</div>
<p>想要更进一步地了解不同类型的Matérn内核请参阅 <a class="reference internal" href="#rw2006" id="id14">[RW2006]</a> , pp84。</p>
</div>
<div class="section" id="id15">
<h3>1.7.5.6. 有理二次内核<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.gaussian_process.kernels.RationalQuadratic.html#sklearn.gaussian_process.kernels.RationalQuadratic" title="sklearn.gaussian_process.kernels.RationalQuadratic"><code class="xref py py-class docutils literal notranslate"><span class="pre">RationalQuadratic</span></code></a> 内核可以被看做不同特征尺度下的 <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.RBF.html#sklearn.gaussian_process.kernels.RBF" title="sklearn.gaussian_process.kernels.RBF"><code class="xref py py-class docutils literal notranslate"><span class="pre">RBF</span></code></a> 内核的规模混合（一个无穷和）
它通过长度尺度参数 <span class="math">l&gt;0</span> 和比例混合参数 <span class="math">\alpha&gt;0</span> 进行参数化。
此时仅支持 <span class="math">l</span> 标量的各向同性变量。内核公式如下：</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = \left(1 + \frac{d(x_i, x_j)^2}{2\alpha l^2}\right)^{-\alpha}</span></p>
</div><p>从 RBF 内核中产生的高斯过程的先验和后验如下图所示：</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_prior_posterior.html"><img alt="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_prior_posterior_001.png" src="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_prior_posterior_001.png" /></a>
</div>
</div>
<div class="section" id="id16">
<h3>1.7.5.7. 正弦平方内核<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.gaussian_process.kernels.ExpSineSquared.html#sklearn.gaussian_process.kernels.ExpSineSquared" title="sklearn.gaussian_process.kernels.ExpSineSquared"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExpSineSquared</span></code></a> 内核可以对周期性函数进行建模。它由定长参数 <span class="math">l&gt;0</span>
以及周期参数 <span class="math">p&gt;0</span> 来实现参数化。此时仅支持 <span class="math">l</span> 标量的各向同性变量。内核公式如下：</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = \text{exp}\left(-2 \left(\text{sin}(\pi / p * d(x_i, x_j)) / l\right)^2\right)</span></p>
</div><p>从ExpSineSquared内核中产生的高斯过程的先验和后验如下图所示：</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_prior_posterior.html"><img alt="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_prior_posterior_002.png" src="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_prior_posterior_002.png" /></a>
</div>
</div>
<div class="section" id="id17">
<h3>1.7.5.8. 点乘内核<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.gaussian_process.kernels.DotProduct.html#sklearn.gaussian_process.kernels.DotProduct" title="sklearn.gaussian_process.kernels.DotProduct"><code class="xref py py-class docutils literal notranslate"><span class="pre">DotProduct</span></code></a> 内核是非固定内核，它可以通过在线性回归的 <span class="math">x_d (d = 1, . . . , D)</span> 的相关系数上加上
服从于 <span class="math">N(0, 1)</span> 的先验以及在线性回归的偏置上加上服从于 <span class="math">N(0, \sigma_0^2)</span> 的先验来获得。
该 <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.DotProduct.html#sklearn.gaussian_process.kernels.DotProduct" title="sklearn.gaussian_process.kernels.DotProduct"><code class="xref py py-class docutils literal notranslate"><span class="pre">DotProduct</span></code></a> 内核对于原点坐标的旋转是不变的，因此不是转换。它通过设置参数 <span class="math">\sigma_0^2</span> 来进行参数化。
当 <span class="math">\sigma_0^2 = 0</span> 时，该内核叫做同质线性内核；否则该内核是非同质的。内核公式如下：</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = \sigma_0 ^ 2 + x_i \cdot x_j</span></p>
</div><p><a class="reference internal" href="generated/sklearn.gaussian_process.kernels.DotProduct.html#sklearn.gaussian_process.kernels.DotProduct" title="sklearn.gaussian_process.kernels.DotProduct"><code class="xref py py-class docutils literal notranslate"><span class="pre">DotProduct</span></code></a> 内核通常和指数分布相结合。实例如下图所示：</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_prior_posterior.html"><img alt="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_prior_posterior_003.png" src="modules/../auto_examples/gaussian_process/images/sphx_glr_plot_gpr_prior_posterior_003.png" /></a>
</div>
</div>
<div class="section" id="id18">
<h3>1.7.5.9. 参考文献<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<table class="docutils citation" frame="void" id="rw2006" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[RW2006]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id10">2</a>, <a class="fn-backref" href="#id14">3</a>)</em> Carl Eduard Rasmussen and Christopher K.I. Williams, “Gaussian Processes for Machine Learning”, MIT Press 2006, Link to an official complete PDF version of the book <a class="reference external" href="http://www.gaussianprocess.org/gpml/chapters/RW.pdf">here</a> .</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id19">
<h2>1.7.6. 传统高斯过程<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
<p>在本节中，描述了版本 0.16.1 及之前 scikit 中高斯过程的实现，
请注意，此实现已被弃用，将在版本 0.18 中删除。</p>
<div class="section" id="id20">
<h3>1.7.6.1. 回归实例介绍<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<p>假定我们要替代这个函数：<span class="math">g(x) = x \sin(x)</span> 。
为了做到这一点，该功能被评估到一个实验设计上。然后，
我们定义一个回归和相关模型可能被其他参数指定的高斯模型，
并且要求模型能够拟合数据。拟合过程由于受到实例化过程中
参数数目的影响可能依赖于参数的最大似然估计或者直接使用给定的参数。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">gaussian_process</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gp</span> <span class="o">=</span> <span class="n">gaussian_process</span><span class="o">.</span><span class="n">GaussianProcess</span><span class="p">(</span><span class="n">theta0</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">thetaL</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">thetaU</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  
<span class="go">GaussianProcess(beta0=None, corr=&lt;function squared_exponential at 0x...&gt;,</span>
<span class="go">        normalize=True, nugget=array(2.22...-15),</span>
<span class="go">        optimizer=&#39;fmin_cobyla&#39;, random_start=1, random_state=...</span>
<span class="go">        regr=&lt;function constant at 0x...&gt;, storage_mode=&#39;full&#39;,</span>
<span class="go">        theta0=array([[ 0.01]]), thetaL=array([[ 0.0001]]),</span>
<span class="go">        thetaU=array([[ 0.1]]), verbose=False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span><span class="p">,</span> <span class="n">sigma2_pred</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">eval_MSE</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h3>1.7.6.2. 噪声数据拟合<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<p>当含噪声的数据被用来做拟合时，对于每个数据点，高斯过程模型可以指定噪声的方差。
<a class="reference internal" href="generated/sklearn.gaussian_process.GaussianProcess.html#sklearn.gaussian_process.GaussianProcess" title="sklearn.gaussian_process.GaussianProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianProcess</span></code></a> 包含一个被添加到训练数据得到的自相关矩阵对角线中的
参数 <code class="docutils literal notranslate"><span class="pre">nugget</span></code> 。通常来说这是一种类型的吉洪诺夫正则化方法。
在平方指数相关函数的特殊情况下，该归一化等效于指定输入中的小数方差。也就是：</p>
<div class="math">
<p><span class="math">\mathrm{nugget}_i = \left[\frac{\sigma_i}{y_i}\right]^2</span></p>
</div><p>使用 <code class="docutils literal notranslate"><span class="pre">nugget</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">corr</span></code> 正确设置，高斯过程可以更好地用于从噪声数据恢复给定的向量函数。</p>
</div>
<div class="section" id="id22">
<h3>1.7.6.3. 数学形式<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id23">
<h4>1.7.6.3.1. 初始假设<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h4>
<p>假设需要对电脑实验的结果进行建模，例如使用一个数学函数：</p>
<div class="math">
<p><span class="math">g: &amp; \mathbb{R}^{n_{\rm features}} \rightarrow \mathbb{R} \\
   &amp; X \mapsto y = g(X)</span></p>
</div><p>同时假设这个函数是 <em>一个</em> 有关于 <em>一个</em> 高斯过程 <span class="math">G</span> 的条件采用方法，
那么从这个假设出发，GPML 通常可以表示为如下形式：</p>
<div class="math">
<p><span class="math">G(X) = f(X)^T \beta + Z(X)</span></p>
</div><p>其中， <span class="math">f(X)^T \beta</span> 是一个线性回归模型，并且 <span class="math">Z(X)</span> 是一个
以零为均值，协方差函数完全平稳的高斯过程：</p>
<div class="math">
<p><span class="math">C(X, X') = \sigma^2 R(|X - X'|)</span></p>
</div><p><span class="math">\sigma^2</span> 表示其方差， <span class="math">R</span> 表示仅仅基于样本之间的绝对相关距离的相关函数，可能是特征（这是平稳性假设）</p>
<p>从这些基本的公式中可以注意到GPML仅仅是基本的线性二乘回归问题的扩展。</p>
<div class="math">
<p><span class="math">g(X) \approx f(X)^T \beta</span></p>
</div><p>除此之外，我们另外假定由相关函数指定的样本之间的一些空间相干性（相关性）。
事实上，普通最小二乘法假设当 <span class="math">X = X'</span> 时，相关性模型 <span class="math">R(|X - X'|)</span>
是 1；否则为 0 ，相关性模型为 <em>狄拉克</em> 相关模型–有时在克里金文献中被称为 <em>熔核</em> 相关模型</p>
</div>
<div class="section" id="blup">
<h4>1.7.6.3.2. 最佳线性无偏预测（BLUP）<a class="headerlink" href="#blup" title="Permalink to this headline">¶</a></h4>
<p>我们现在推导出基于观测结果的 <em>最佳线性无偏预测</em> <span class="math">g</span></p>
<div class="math">
<p><span class="math">\hat{G}(X) = G(X | y_1 = g(X_1), ...,
                            y_{n_{\rm samples}} = g(X_{n_{\rm samples}}))</span></p>
</div><p>它可以由 <em>给定的属性</em> 加以派生：</p>
<ul class="simple">
<li>它是线性的(观测结果的线性组合)</li>
</ul>
<div class="math">
<p><span class="math">\hat{G}(X) \equiv a(X)^T y</span></p>
</div><ul class="simple">
<li>它是无偏的</li>
</ul>
<div class="math">
<p><span class="math">\mathbb{E}[G(X) - \hat{G}(X)] = 0</span></p>
</div><ul class="simple">
<li>它是最好的（在均方误差的意义上）</li>
</ul>
<div class="math">
<p><span class="math">\hat{G}(X)^* = \arg \min\limits_{\hat{G}(X)} \;
                                        \mathbb{E}[(G(X) - \hat{G}(X))^2]</span></p>
</div><p>因此最优的带权向量 <span class="math">a(X)</span> 是以下等式约束优化问题的解</p>
<div class="math">
<p><span class="math">a(X)^* = \arg \min\limits_{a(X)} &amp; \; \mathbb{E}[(G(X) - a(X)^T y)^2] \\
                   {\rm s. t.} &amp; \; \mathbb{E}[G(X) - a(X)^T y] = 0</span></p>
</div><p>以拉格朗日形式重写这个受约束的优化问题，并进一步寻求要满足的一阶最优条件，
从而得到一个以闭合形式表达式为终止形式的预测器 - 参见参考文献中完整的证明。</p>
<p>最后，BLUP 为高斯随机变量，其中均值为：</p>
<div class="math">
<p><span class="math">\mu_{\hat{Y}}(X) = f(X)^T\,\hat{\beta} + r(X)^T\,\gamma</span></p>
</div><p>方差为:</p>
<div class="math">
<p><span class="math">\sigma_{\hat{Y}}^2(X) = \sigma_{Y}^2\,
( 1
- r(X)^T\,R^{-1}\,r(X)
+ u(X)^T\,(F^T\,R^{-1}\,F)^{-1}\,u(X)
)</span></p>
</div><p>其中:</p>
<ul class="simple">
<li>根据自相关函数以及内置参数 <span class="math">\theta</span> 所定义的相关性矩阵为：</li>
</ul>
<div class="math">
<p><span class="math">R_{i\,j} = R(|X_i - X_j|, \theta), \; i,\,j = 1, ..., m</span></p>
</div><ul class="simple">
<li>在进行预测的点与 DOE 中的点之间的互相关的向量:</li>
</ul>
<div class="math">
<p><span class="math">r_i = R(|X - X_i|, \theta), \; i = 1, ..., m</span></p>
</div><ul class="simple">
<li>回归矩阵 (例如范德蒙矩阵 如果 <span class="math">f</span> 以多项式为基):</li>
</ul>
<div class="math">
<p><span class="math">F_{i\,j} = f_i(X_j), \; i = 1, ..., p, \, j = 1, ..., m</span></p>
</div><ul class="simple">
<li>广义最小二乘回归权重:</li>
</ul>
<div class="math">
<p><span class="math">\hat{\beta} =(F^T\,R^{-1}\,F)^{-1}\,F^T\,R^{-1}\,Y</span></p>
</div><ul class="simple">
<li>和向量:</li>
</ul>
<div class="math">
<p><span class="math">\gamma &amp; = R^{-1}(Y - F\,\hat{\beta}) \\
u(X) &amp; = F^T\,R^{-1}\,r(X) - f(X)</span></p>
</div><p>需要重点注意的是，高斯过程预测器的概率输出是完全可分析的并且依赖于基本的线性代数操作。
更准确地说，预测结果的均值是两个简单线性组合（点积）的和，方差需要两个矩阵反转操作，但关联
矩阵只能使用 Cholesky 分解算法分解一次。</p>
</div>
<div class="section" id="eblup">
<h4>1.7.6.3.3. 经验最佳线性无偏估计（EBLUP）<a class="headerlink" href="#eblup" title="Permalink to this headline">¶</a></h4>
<p>到现在为止，自相关和回归模型都已假定给出。然而，在实践中，它们从来都是未知的
因此需要为这些模型 <a class="reference internal" href="#correlation-models"><span class="std std-ref">关联模型</span></a> 做出（积极的）经验选择。</p>
<p>根据这些选择，可以来估计 BLUP 中涉及到的遗留未知参数。为此，需要使用一系列
被提供的观测值同时结合一系列推断技术。目前使用的方法是基于 DACE’s Matlab 工
具包的*最大似然估计* - 参见 DACE 手册中的完全推导公式。最大似然估计的问题在
自相关参数中是一个全局优化的问题。这种全局优化通过 scipy.optimize 中的
fmin_cobyla 优化函数加以实现。然而，在各向异性的情况下，我们提供了
Welch 的分量优化算法的实现 - 参见参考。</p>
</div>
</div>
<div class="section" id="correlation-models">
<span id="id24"></span><h3>1.7.6.4. 关联模型<a class="headerlink" href="#correlation-models" title="Permalink to this headline">¶</a></h3>
<p>由于几乎相等的假设，常用的关联模型和一些有名的SVM内核相匹配。它们必须要满足 Mercer 条件
并且需要保持固定形式。然而，请注意，相关模型的选择应该与观察到来的原始实验的已知特性一致。
例如：</p>
<ul class="simple">
<li>如果原始实验被认为是无限可微（平滑），则应使用 <em>平方指数关联模型</em> 。</li>
<li>如果不是无限可微的, 那么需要使用 <em>指数关联模型</em>.</li>
<li>还要注意，存在一个将衍生度作为输入的相关模型：这是 Matern 相关模型，但这里并没有实现（ TODO ）.</li>
</ul>
<p>关于选择合适的关联模型更详细的讨论，请参阅 Rasmussen＆Williams 的文献。</p>
</div>
<div class="section" id="regression-models">
<span id="id25"></span><h3>1.7.6.5. 回归模型<a class="headerlink" href="#regression-models" title="Permalink to this headline">¶</a></h3>
<p>常用的线性回归模型包括零阶（常数）、一阶和二阶多项式。
但是可以以 Python 函数的形式指定它自己的特性，它将特征X
作为输入，并返回一个包含函数集值的向量。唯一加以限制地是，
函数的个数不能超过有效观测值的数目，因此基本的回归问题不被*确定*。</p>
</div>
<div class="section" id="id26">
<h3>1.7.6.6. 实现细节<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h3>
<p>模型通过 DACE 的 Matlab 工具包来实现。</p>
<div class="topic">
<p class="topic-title first">参考文献:</p>
<ul class="simple">
<li><a class="reference external" href="http://imedea.uib-csic.es/master/cambioglobal/Modulo_V_cod101615/Lab/lab_maps/krigging/DACE-krigingsoft/dace/dace.pdf">DACE, A Matlab Kriging Toolbox</a> S Lophaven, HB Nielsen, J
Sondergaard 2002,</li>
<li>W.J. Welch, R.J. Buck, J. Sacks, H.P. Wynn, T.J. Mitchell, and M.D.
Morris (1992). Screening, predicting, and computer experiments.
Technometrics, 34(1) 15–25.</li>
</ul>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>

      <!-- 评论留言区代码 start -->
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNDAwMi8xMDU0MA==">
        <script type="text/javascript">
        (function(d, s) {
            var j, e = d.getElementsByTagName(s)[0];

            if (typeof LivereTower === 'function') { return; }

            j = d.createElement(s);
            j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
            j.async = true;

            e.parentNode.insertBefore(j, e);
        })(document, 'script');
        </script>
      </div>
      <!-- 评论留言区代码 end -->

    </div>

    <!-- 提 PR 时按原来文档的字母排序 -->

    

    

    

    

    

    

    

    

    

    
    <!-- modules/gaussian_process.html -->
    <div class="apachecn_doc_right">
      校验者: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/apachecn/scikit-learn-doc-zh">@glassy</a><br/>
                 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/apachecn/scikit-learn-doc-zh">@Trembleguy</a><br/>
      翻译者: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/apachecn/scikit-learn-doc-zh">@AI追寻者</a><br/>
    </div>
    

    

    

    

    

    

    

    

    

    

    
    
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

  </div>

  <div class="footer">
      &copy; 2007 - 2017, scikit-learn developers (BSD License).
    <a href="../_sources/modules/gaussian_process.rst.txt" rel="nofollow">Show this page source</a>
  </div>
   <div class="rel">
  
  <div class="buttonPrevious">
    <a href="neighbors.html">Previous
    </a>
  </div>
  <div class="buttonNext">
    <a href="cross_decomposition.html">Next
    </a>
  </div>
  
   </div>

  <!-- google analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  
    ga('create', 'UA-102475051-5', 'auto');
    ga('send', 'pageview');
  
  </script>
  
  <!-- baidu tongji -->
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?9cbab13b4d28a9811ae1d2d2176dab66";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>

  <!-- baidu push -->
  <script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script>
  </body>
</html>


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>7. 计算性能 &#8212; scikit-learn 0.19.0 中文文档 - ApacheCN</title>
<!-- htmltitle is before nature.css - we use this hack to load bootstrap first -->
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="../_static/css/bootstrap.min.css" media="screen" />
<link rel="stylesheet" href="../_static/css/bootstrap-responsive.css"/>

    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="General examples" href="../auto_examples/index.html" />
    <link rel="prev" title="6. 大规模计算的策略: 更大量的数据" href="scaling_strategies.html" />


<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<script src="../_static/js/bootstrap.min.js" type="text/javascript"></script>
<link rel="canonical" href="http://scikit-learn.org/stable/modules/computational_performance.html" />

<script type="text/javascript">
  $("div.buttonNext, div.buttonPrevious").hover(
     function () {
         $(this).css('background-color', '#FF9C34');
     },
     function () {
         $(this).css('background-color', '#A7D6E2');
     }
  );
  function showMenu() {
    var topNav = document.getElementById("scikit-navbar");
    if (topNav.className === "navbar") {
        topNav.className += " responsive";
    } else {
        topNav.className = "navbar";
    }
  };
</script>

  </head><body>

<div class="header-wrapper">
  <div class="header">
      <p class="logo"><a href="../index.html">
          <img src="../_static/scikit-learn-logo-small.png" alt="Logo"/>
      </a>
      </p><div class="navbar" id="scikit-navbar">
          <ul>
              <li><a href="../index.html">首页</a></li>
              <li><a href="../install.html">安装</a></li>
              <li class="btn-li">
                <div class="btn-group">
                    <a href="../documentation.html">文档</a>
                    <a class="btn dropdown-toggle" data-toggle="dropdown">
                      <span class="caret"></span>
                    </a>
                    <ul class="dropdown-menu">
                      <li class="link-title">Scikit-learn 0.19</li>
                      <li><a href="../tutorial/index.html">教程</a></li>
                      <li><a href="../user_guide.html">用户指南</a></li>
                      <li><a href="classes.html">API</a></li>
                      <li><a href="../faq.html">FAQ</a></li>
                      <li><a href="../developers/contributing.html">贡献</a></li>
                      <li class="divider"></li>
                      <li><a href="http://scikit-learn.org/stable/documentation.html">Scikit-learn 0.19 (stable)</a></li>
                      <li><a href="http://scikit-learn.org/0.18/documentation.html">Scikit-learn 0.18</a></li>
                      <li><a href="http://scikit-learn.org/0.17/documentation.html">Scikit-learn 0.17</a></li>
                      <li><a href="../_downloads/scikit-learn-docs.pdf">PDF 文档</a></li>
                    </ul>
                </div>
              </li>
              <li><a href="../auto_examples/index.html">示例</a></li>
              <li><a href="../project-timeline.html">时光轴</a></li>
              <li class="btn-li">
                <div class="btn-group">
                    <a href="javascript:void(0)">项目相关</a>
                    <a class="btn dropdown-toggle" data-toggle="dropdown">
                      <span class="caret"></span>
                    </a>
                    <ul class="dropdown-menu">
                      <li><a href="../project-role.html">项目角色</a></li>
                      <li><a href="../project-check-progress.html">校验进度</a></li>
                      <li><a href="../project-translation-progress.html">翻译进度</a></li>
                      <li><a href="//github.com/apachecn/scikit-learn-doc-zh#%E8%B4%A1%E7%8C%AE%E8%80%85" target="_blank">贡献者</a></li>
                      <li class="divider"></li>
                      <li><a href="../project-timeline.html">时光轴</a></li>
                      <li class="divider"></li>
                      <li><a href="../project-reward.html">项目奖励</a></li>
                      <li class="divider"></li>
                      <li><a href="http://www.apachecn.org/organization/244.html" target="_blank">积分物品</a></li>
                      <li><a href="http://www.apachecn.org/organization/269.html" target="_blank">兑换记录</a></li>
                      <li class="divider"></li>
                      <li><a href="../project-feedback.html">建议反馈</a></li>
                      <li><a href="../project-communication-group.html">技术交流</a></li>
                    </ul>
                </div>
              </li>
              <li><a href="//github.com/apachecn/scikit-learn-doc-zh#%E8%B4%A1%E7%8C%AE%E8%80%85" target="_blank">贡献者</a></li>
              <li><a href="//github.com/apachecn/scikit-learn-doc-zh" target="_blank">GitHub</a></li>
          </ul>
          <a href="javascript:void(0);" onclick="showMenu()">
              <div class="nav-icon">
                  <div class="hamburger-line"></div>
                  <div class="hamburger-line"></div>
                  <div class="hamburger-line"></div>
              </div>
          </a>
          <div class="search_form">
              <div class="gcse-search" id="cse" style="width: 100%;"></div>
          </div>
      </div> <!-- end navbar --></div>
</div>


<!-- Github "fork me" ribbon -->
<a href="https://github.com/apachecn/scikit-learn-doc-zh">
<img class="fork-me"
     style="position: absolute; top: 0; right: 0; border: 0;"
     src="../_static/img/starme.png"
     alt="Star me on GitHub" />
</a>

<div class="content-wrapper">
  <div class="sphinxsidebar">
  <div class="sphinxsidebarwrapper">
      <div class="rel">
  
      <div class="rellink">
      <a href="scaling_strategies.html"
      accesskey="P">Previous
      <br/>
      <span class="smallrellink">
      6. 大规模计算的策略: 更大量的数据
      </span>
          <span class="hiddenrellink">
          6. 大规模计算的策略: 更大量的数据
          </span>
      </a>
      </div>
          <div class="spacer">
          &nbsp;
          </div>
      <div class="rellink">
      <a href="../auto_examples/index.html"
      accesskey="N">Next
      <br/>
      <span class="smallrellink">
      General examples
      </span>
          <span class="hiddenrellink">
          General examples
          </span>
      </a>
      </div>

  <!-- Ad a link to the 'up' page -->
      <div class="spacer">
      &nbsp;
      </div>
      <div class="rellink">
      <a href="../user_guide.html">
      Up
      <br/>
      <span class="smallrellink">
      用户指南
      </span>
          <span class="hiddenrellink">
          用户指南
          </span>
          
      </a>
      </div>
  </div>
  
    <p class="doc-version"><b>scikit-learn v0.19.0</b><br/>
    <a href="http://scikit-learn.org/stable/support.html#documentation-resources">Other versions</a></p>
  <p class="citing">Please <b><a href="../about.html#citing-scikit-learn" style="font-size: 110%;">cite us </a></b>if you use the software.</p>
  <ul>
<li><a class="reference internal" href="#">7. 计算性能</a><ul>
<li><a class="reference internal" href="#id2">7.1. 预测延迟</a><ul>
<li><a class="reference internal" href="#id3">7.1.1. 批量与原子模式</a></li>
<li><a class="reference internal" href="#id4">7.1.2. 特征数量的影响</a></li>
<li><a class="reference internal" href="#id5">7.1.3. 输入数据表示的影响</a></li>
<li><a class="reference internal" href="#id6">7.1.4. 模型复杂度的影响</a></li>
<li><a class="reference internal" href="#id7">7.1.5. 特征提取延迟</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">7.2. 预测吞吐量</a></li>
<li><a class="reference internal" href="#id9">7.3. 技巧和窍门</a><ul>
<li><a class="reference internal" href="#id10">7.3.1. 线性代数库</a></li>
<li><a class="reference internal" href="#id11">7.3.2. 模型压缩</a></li>
<li><a class="reference internal" href="#id12">7.3.3. 模型重塑</a></li>
<li><a class="reference internal" href="#id13">7.3.4. 链接</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<input type="checkbox" id="nav-trigger" class="nav-trigger" checked />
<label for="nav-trigger"></label>




    <div class="content">
          
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="computational-performance">
<span id="id1"></span><h1>7. 计算性能<a class="headerlink" href="#computational-performance" title="Permalink to this headline">¶</a></h1>
<p>对于某些 applications （应用），estimators（估计器）的性能（主要是 prediction time （预测时间）的 latency （延迟）和 throughput （吞吐量））至关重要。考虑 training throughput （训练吞吐量）也可能是有意义的，但是在 production setup （生产设置）（通常在脱机中运行）通常是不太重要的。</p>
<p>我们将在这里审查您可以从不同上下文中的一些 scikit-learn estimators（估计器）预期的数量级，并提供一些 overcoming performance bottlenecks （解决性能瓶颈）的技巧和诀窍。</p>
<p>将 Prediction latency （预测延迟）作为进行预测所需的 elapsed time （经过时间）（例如，以 micro-seconds（微秒）为单位）进行测量。Latency （延迟）通常被认为一种分布，运营工程师通常将注意力集中在该分布的给定 percentile （百分位数）（例如 90 百分位数）上的延迟。</p>
<p>Prediction throughput （预测吞吐量）被定义为软件可以在给定的时间量内（例如每秒的预测）中 the number of predictions （可预测的预测数）。</p>
<p>performance optimization （性能优化）的一个重要方面也是它可能会损害 prediction accuracy （预测精度）。 实际上，更简单的模型（例如 linear （线性的），而不是 non-linear （非线性的），或者具有较少的参数）通常运行得更快，但并不总是能够考虑与更复杂的数据相同的确切属性。</p>
<div class="section" id="id2">
<h2>7.1. 预测延迟<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>在使用/选择机器学习工具包时可能遇到的最直接的问题之一是生产环境中可以进行预测的 latency （延迟）。</p>
<dl class="docutils">
<dt>影响 prediction latency （预测延迟）的主要因素是</dt>
<dd><ol class="first last arabic simple">
<li>Number of features（特征的数量）</li>
<li>Input data representation and sparsity（输入数据的表示和稀疏性）</li>
<li>Model complexity（模型复杂性）</li>
<li>Feature extraction（特征提取）</li>
</ol>
</dd>
</dl>
<p>最后一个主要参数也是在 bulk or one-at-a-time mode （批量或执行一次的时间模式）下进行预测的可能性。</p>
<div class="section" id="id3">
<h3>7.1.1. 批量与原子模式<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>通常，通过大量原因（branching predictability（分支可预测性）, CPU cache（CPU缓存）, linear algebra libraries optimizations（线性代数库优化）等），predictions in bulk（批量进行预测）（同时许多情况）更有效。 在这里，我们看到一些具有很少功能的设置，独立于估计器选择，bulk mode（批量模式）总是更快，而对于其中的一些，它们的数量大约是 1 到 2 个数量级:</p>
<p class="centered">
<strong><a class="reference external" href="../auto_examples/applications/plot_prediction_latency.html"><img alt="atomic_prediction_latency" src="modules/../auto_examples/applications/images/sphx_glr_plot_prediction_latency_001.png" /></a></strong></p><p class="centered">
<strong><a class="reference external" href="../auto_examples/applications/plot_prediction_latency.html"><img alt="bulk_prediction_latency" src="modules/../auto_examples/applications/images/sphx_glr_plot_prediction_latency_002.png" /></a></strong></p><p>为了对您的案例的不同的 estimators 进行基准测试，您可以在此示例中简单地更改 <code class="docutils literal notranslate"><span class="pre">n_features</span></code> 参数:
<a class="reference internal" href="../auto_examples/applications/plot_prediction_latency.html#sphx-glr-auto-examples-applications-plot-prediction-latency-py"><span class="std std-ref">Prediction Latency</span></a>. 这应该给你估计 prediction latency （预测延迟）的数量级。</p>
<div class="topic">
<p class="topic-title first">配置 Scikit-learn 来减少验证开销</p>
<p>Scikit-learn 对数据进行了一些验证，从而增加了对 <code class="docutils literal notranslate"><span class="pre">predict（预测）</span></code> 和类似函数的调用开销。特别地，检查这些 features （特征）是有限的（不是 NaN 或无限）涉及对数据的完全传递。如果您确定你的数据是 acceptable （可接受的），您可以通过在导入 scikit-learn 之前将环境变量配置 <code class="docutils literal notranslate"><span class="pre">SKLEARN_ASSUME_FINITE</span></code> 设置为 non-empty string （非空字符串）来抑制检查有限性，或者使用以下方式在 Python 中配置 <a class="reference internal" href="generated/sklearn.set_config.html#sklearn.set_config" title="sklearn.set_config"><code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config</span></code></a> 。为了比这些全局设置更多的控制 <code class="xref py py-func docutils literal notranslate"><span class="pre">config_context</span></code> 允许您在指定的上下文中设置此配置:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sklearn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">config_context</span><span class="p">(</span><span class="n">assume_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">pass</span>  <span class="c1"># do learning/prediction here with reduced validation</span>
</pre></div>
</div>
<p>注意，这将影响上下文中的 <a class="reference internal" href="generated/sklearn.utils.assert_all_finite.html#sklearn.utils.assert_all_finite" title="sklearn.utils.assert_all_finite"><code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.utils.assert_all_finite</span></code></a> 的所有用途。</p>
</div>
</div>
<div class="section" id="id4">
<h3>7.1.2. 特征数量的影响<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>显然，当特征数量增加时，每个示例的内存消耗量也会增加。实际上，对于具有 <span class="math">N</span> 个特征的 <span class="math">M</span> 个实例的矩阵，空间复杂度在 <span class="math">O(NM)</span> 。</p>
<p>从 computing （计算）角度来看，这也意味着 the number of basic operations （基本操作的数量）（例如，线性模型中向量矩阵乘积的乘法）也增加。以下是 prediction latency (预测延迟)与 number of features(特征数) 的变化图:</p>
<p class="centered">
<strong><a class="reference external" href="../auto_examples/applications/plot_prediction_latency.html"><img alt="influence_of_n_features_on_latency" src="modules/../auto_examples/applications/images/sphx_glr_plot_prediction_latency_003.png" /></a></strong></p><p>总的来说，您可以预期 prediction time （预测时间）至少随 number of features （特征数量）线性增加（非线性情况可能会发生，取决于 global memory footprint （全局内存占用）和 estimator （估计））。</p>
</div>
<div class="section" id="id5">
<h3>7.1.3. 输入数据表示的影响<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>Scipy 提供对 storing sparse data（存储稀疏数据）进行优化的 sparse matrix （稀疏矩阵）数据结构。sparse formats（稀疏格式）的主要特点是您不会存储零，所以如果您的数据稀疏，那么您使用的内存会更少。sparse（稀疏） (<a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/sparse.html">CSR or CSC</a>) 表示中的非零值将仅占用一个 32 位整数位置 + 64 位 floating point （浮点值） + 矩阵中每行或列的额外的 32 位。在 dense（密集） (or sparse（稀疏）) 线性模型上使用稀疏输入可以加速预测，只有非零值特征才会影响点积，从而影响模型预测。因此，如果在 1e6 维空间中有 100 个非零，则只需要 100 次乘法和加法运算而不是 1e6 。</p>
<p>然而，密度表示的计算可以利用 BLAS 中高度优化的向量操作和多线程，并且往往导致更少的 CPU 高速缓存 misses 。因此，sparse input （稀疏输入）表示的 sparsity （稀疏度）通常应相当高（10% 非零最大值，要根据硬件进行检查）比在具有多个 CPU 和优化 BLAS 实现的机器上的 dense input （密集输入）表示更快。</p>
<p>以下是测试输入 sparsity （稀疏度）的示例代码:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sparsity_ratio</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;input sparsity ratio:&quot;</span><span class="p">,</span> <span class="n">sparsity_ratio</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
</pre></div>
</div>
<p>根据经验，您可以考虑如果 sparsity ratio （稀疏比）大于 90% , 您可能会从 sparse formats （稀疏格式）中受益。有关如何构建（或将数据转换为） sparse matrix formats （稀疏矩阵格式）的更多信息，请参阅 Scipy 的稀疏矩阵格式文档 <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/sparse.html">documentation</a> 。大多数的时候, <code class="docutils literal notranslate"><span class="pre">CSR</span></code> 和 <code class="docutils literal notranslate"><span class="pre">CSC</span></code> 格式是最有效的。</p>
</div>
<div class="section" id="id6">
<h3>7.1.4. 模型复杂度的影响<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>一般来说，当 model complexity （模型复杂度）增加时，predictive power （预测能力）和 latency （延迟）应该会增加。增加 predictive power （预测能力）通常很有意思，但对于许多应用，我们最好不要太多地增加预测延迟。我们现在将对不同 families 的 supervised models （监督模式）进行审查。</p>
<p>对于 <a class="reference internal" href="classes.html#module-sklearn.linear_model" title="sklearn.linear_model"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.linear_model</span></code></a> (例如 Lasso, ElasticNet, SGDClassifier/Regressor, Ridge &amp; RidgeClassifier, PassiveAgressiveClassifier/Regressor, LinearSVC, LogisticRegression…) 在预测时间应用的 decision function （决策函数）是一样的（dot product（ 点积）），所以 latency （延迟）应该是等效的。</p>
<p>这里有一个例子使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.linear_model.stochastic_gradient.SGDClassifier</span></code> 和 <code class="docutils literal notranslate"><span class="pre">elasticnet</span></code> penalty（惩罚）。 regularization strength（正则化强度）由 <code class="docutils literal notranslate"><span class="pre">alpha</span></code> 参数全局控制。有一个足够高的 <code class="docutils literal notranslate"><span class="pre">alpha</span></code> ，可以增加 <code class="docutils literal notranslate"><span class="pre">elasticnet</span></code> 的 <code class="docutils literal notranslate"><span class="pre">l1_ratio</span></code> 参数，以在模型参数中执行各种稀疏程度。这里的 Higher sparsity （较高稀疏度）被解释为 less model complexity （较少的模型复杂度），因为我们需要较少的系数充分描述它。当然， sparsity （稀疏性）会随着稀疏点积 产生时间大致与非零系数的数目成比例地影响 prediction time （预测时间）。</p>
<p class="centered">
<strong><a class="reference external" href="../auto_examples/applications/plot_model_complexity_influence.html"><img alt="en_model_complexity" src="modules/../auto_examples/applications/images/sphx_glr_plot_model_complexity_influence_001.png" /></a></strong></p><p>对于具有 non-linear kernel （非线性内核）的 <a class="reference internal" href="classes.html#module-sklearn.svm" title="sklearn.svm"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.svm</span></code></a> 算法系列，latency （延迟）与 support vectors （支持向量）的数量有关（越少越快）。
随着 SVC 或 SVR 模型中的支持向量的数量， Latency （延迟）和 throughput （吞吐量）应该渐渐地增长。kernel （内核）也将影响 latency （延迟），因为它用于计算每个 support vector （支持向量）一次 input vector（输入向量）的 projection （投影）。在下面的图中， <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.svm.classes.NuSVR</span></code> 的 <code class="docutils literal notranslate"><span class="pre">nu</span></code> 参数用于影响 number of support vectors（支持向量的数量）。</p>
<p class="centered">
<strong><a class="reference external" href="../auto_examples/applications/plot_model_complexity_influence.html"><img alt="nusvr_model_complexity" src="modules/../auto_examples/applications/images/sphx_glr_plot_model_complexity_influence_002.png" /></a></strong></p><p>对于 <a class="reference internal" href="classes.html#module-sklearn.ensemble" title="sklearn.ensemble"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.ensemble</span></code></a> 的 trees （例如 RandomForest, GBT, ExtraTrees 等） number of trees （树的数量）及其 depth（深度）发挥着最重要的作用。Latency and throughput（延迟和吞吐量）应与树的数量呈线性关系。在这种情况下，我们直接使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.ensemble.gradient_boosting.GradientBoostingRegressor</span></code> 的 <code class="docutils literal notranslate"><span class="pre">n_estimators</span></code> 参数。</p>
<p class="centered">
<strong><a class="reference external" href="../auto_examples/applications/plot_model_complexity_influence.html"><img alt="gbt_model_complexity" src="modules/../auto_examples/applications/images/sphx_glr_plot_model_complexity_influence_003.png" /></a></strong></p><p>在任何情况下都应该警告，降低的 model complexity （模型复杂性）可能会损害如上所述的准确性。例如，可以用快速线性模型来处理 non-linearly separable problem （非线性可分离问题），但是在该过程中预测能力将很可能受到影响。</p>
</div>
<div class="section" id="id7">
<h3>7.1.5. 特征提取延迟<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>大多数 scikit-learn 模型通常非常快，因为它们可以通过编译的 Cython 扩展或优化的计算库来实现。
另一方面，在许多现实世界的应用中，feature extraction process（特征提取过程）（即，将 database rows or network packets （数据库行或网络分组）的原始数据转换为 numpy arrays ）来控制总体预测时间。例如在 Reuters text classification task（路透社文本分类任务）中，根据所选择的模型，整个准备（读取和解析 SGML 文件，将文本进行标记并将其散列为公共向量空间）的时间比实际预测代码的时间长 100 到 500 倍。</p>
<blockquote>
<div></div></blockquote>
<p class="centered">
<strong><a class="reference external" href="../auto_examples/applications/plot_out_of_core_classification.html"><img alt="prediction_time" src="modules/../auto_examples/applications/images/sphx_glr_plot_out_of_core_classification_004.png" /></a></strong></p><p>因此，在很多情况下，建议您仔细地对 carefully time and profile your feature extraction code ( 特征提取代码进行时间预估和简档)，因为当您的 overall latency （整体延迟）对您的应用程序来说太慢时，可能是开始优化的好地方。</p>
</div>
</div>
<div class="section" id="id8">
<h2>7.2. 预测吞吐量<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>考虑到生产系统大小的另一个重要指标是 throughput （吞吐量），即在一定时间内可以做出的预测数量。以下是 <a class="reference internal" href="../auto_examples/applications/plot_prediction_latency.html#sphx-glr-auto-examples-applications-plot-prediction-latency-py"><span class="std std-ref">Prediction Latency</span></a> 示例的基准测试，该示例针对合成数据的多个 estimators （估计器）测量此数量:</p>
<p class="centered">
<strong><a class="reference external" href="../auto_examples/applications/plot_prediction_latency.html"><img alt="throughput_benchmark" src="modules/../auto_examples/applications/images/sphx_glr_plot_prediction_latency_004.png" /></a></strong></p><p>这些 throughputs（吞吐量）早单个进程上实现。提高应用程序吞吐量的一个明显的方法是产生其他实例（通常是 Python 中的进程，因为 <a class="reference external" href="https://wiki.python.org/moin/GlobalInterpreterLock">GIL</a> ）共享相同模型。还可能添加机器来分布式负载。关于如何实现这一点的详细解释超出了本文档的范围。</p>
</div>
<div class="section" id="id9">
<h2>7.3. 技巧和窍门<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id10">
<h3>7.3.1. 线性代数库<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>由于 scikit-learn 在很大程度上依赖于 Numpy/Scipy 和 线性代数，所以需要理解这些库的版本。
基本上，你应该确保使用优化的 <a class="reference external" href="https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms">BLAS</a> / <a class="reference external" href="https://en.wikipedia.org/wiki/LAPACK">LAPACK</a> 构建 Numpy 库。</p>
<p>并非所有的模型都受益于优化的 BLAS 和 Lapack 实现。例如，基于（随机化）决策树的模型通常不依赖于内部循环中的 BLAS 调用，kernel SVMs (<code class="docutils literal notranslate"><span class="pre">SVC</span></code>, <code class="docutils literal notranslate"><span class="pre">SVR</span></code>, <code class="docutils literal notranslate"><span class="pre">NuSVC</span></code>, <code class="docutils literal notranslate"><span class="pre">NuSVR</span></code>) 。另一方面，使用 BLAS DGEMM 调用（通过 <code class="docutils literal notranslate"><span class="pre">numpy.dot</span></code>）实现的线性模型通常将受益于调整的 BLAS 实现，并且导致非优化 BLAS 的数量级加速。</p>
<p>你可以使用以下命令显示您的 NumPy / SciPy / scikit-learn 安装使用的 BLAS / LAPACK 实现:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy.distutils.system_info</span> <span class="k">import</span> <span class="n">get_info</span>
<span class="nb">print</span><span class="p">(</span><span class="n">get_info</span><span class="p">(</span><span class="s1">&#39;blas_opt&#39;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">get_info</span><span class="p">(</span><span class="s1">&#39;lapack_opt&#39;</span><span class="p">))</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Optimized(优化的) BLAS / LAPACK 实现包括:</dt>
<dd><ul class="first last simple">
<li>Atlas (需要通过在目标机器上 rebuilding 进行硬件特定调整)</li>
<li>OpenBLAS</li>
<li>MKL</li>
<li>Apple Accelerate 和 vecLib frameworks (仅适用于 OSX)</li>
</ul>
</dd>
</dl>
<p>有关更多信息，请参见 <a class="reference external" href="http://docs.scipy.org/doc/numpy/user/install.html">Scipy install page</a> 并在来自 Daniel Nouri 的博客  <a class="reference external" href="http://danielnouri.org/notes/2012/12/19/libblas-and-liblapack-issues-and-speed,-with-scipy-and-ubuntu/">blog post</a> 它为 Debain / Ubuntu 提供了一些很好的一步一步的安装说明。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Multithreaded BLAS libraries（多线程 BLAS 库）有时与 Python 的 <code class="docutils literal notranslate"><span class="pre">multiprocessing</span></code> 模块相冲突，这个模块由例如 <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> 和大多数其他估计器，它们使用 <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code> 参数（除了 <code class="docutils literal notranslate"><span class="pre">SGDClassifier</span></code>, <code class="docutils literal notranslate"><span class="pre">SGDRegressor</span></code>, <code class="docutils literal notranslate"><span class="pre">Perceptron</span></code>, <code class="docutils literal notranslate"><span class="pre">PassiveAggressiveClassifier</span></code> 和 基于树的方法如 random forests（随机森林））。在 OpenMP 支持的情况下， Apple 的 Accelerate 和 OpenBLAS 也是如此。</p>
<p>除了 scikit-learn, Numpy 和 Scipy 也在内部使用 BLAS, 如上所述。</p>
<p class="last">如果您遇到带有 <code class="docutils literal notranslate"><span class="pre">n_jobs&gt;1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">n_jobs=-1</span></code> 的 hanging subprocesses （挂起子进程），请确保你有一个单线程 BLAS 库，或者设置 <code class="docutils literal notranslate"><span class="pre">n_jobs=1</span></code> 或者升级到 Python 3.4 有一个新版本的 <code class="docutils literal notranslate"><span class="pre">multiprocessing</span></code> ，应该免于这个问题。</p>
</div>
</div>
<div class="section" id="id11">
<h3>7.3.2. 模型压缩<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>scikit-learn 中的 Model compression （模型压缩）只关注 linear models （线性模型）。
在这种情况下，这意味着我们要控制模型 sparsity （稀疏度）（即 模型向量中的非零坐标数）。将 model sparsity （模型稀疏度）与 sparse input data representation （稀疏输入数据表示）相结合是一个好主意。</p>
<p>以下是示例代码，说明了如何使用 <code class="docutils literal notranslate"><span class="pre">sparsify()</span></code> 方法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clf</span> <span class="o">=</span> <span class="n">SGDRegressor</span><span class="p">(</span><span class="n">penalty</span><span class="o">=</span><span class="s1">&#39;elasticnet&#39;</span><span class="p">,</span> <span class="n">l1_ratio</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
<span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span><span class="o">.</span><span class="n">sparsify</span><span class="p">()</span>
<span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
</pre></div>
</div>
<p>在这个例子中，我们更喜欢 <code class="docutils literal notranslate"><span class="pre">elasticnet</span></code> penalty（惩罚），因为它通常是 model compactness（模型紧凑性）和 prediction power （预测能力）之间的一个很好的妥协。还可以进一步调整 <code class="docutils literal notranslate"><span class="pre">l1_ratio</span></code> 参数（结合正则化强度 <code class="docutils literal notranslate"><span class="pre">alpha</span></code> ）来控制这个权衡。</p>
<p>对于 synthetic data （合成数据），典型的 <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/master/benchmarks/bench_sparsify.py">benchmark</a> 在模型和输入时都会降低 30% 的延迟。稀疏（分别为 0.000024 和 0.027400 非零系数比）。您的里程可能会因您的数据和模型的稀疏性和大小而有所不同。
因此，为了减少部署在生产服务器上的预测模型的内存使用，扩展可能非常有用。</p>
</div>
<div class="section" id="id12">
<h3>7.3.3. 模型重塑<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>Model reshaping（模型重塑）在于仅选择一部分可用功能以适应模型。换句话说，如果模型在学习阶段 discards features （丢弃特征），我们可以从输入中删除这些特征。这有几个好处。首先，它减少了模型本身的内存（因此是减少了时间）的开销。一旦知道要从上一次运行中保留哪些功能，它也允许在 pipeline 中 discard explicit feature selection components （丢弃显式的特征选择组件）。最后，它可以通过不收集和构建模型丢弃的特征来帮助减少数据访问和 feature extraction layers （特征提取层）upstream （上游）的处理时间和 I/O 的使用。例如，如果原始数据来自数据库，则可以通过使查询返回较轻的记录，从而可以编写更简单和更快速的查询或减少 I/O 的使用。
目前，reshaping（重塑）需要在 scikit-learn 中手动执行。
在 sparse input（稀疏输入）（特别是 <code class="docutils literal notranslate"><span class="pre">CSR</span></code> 格式）的情况下，通常不能生成相关的特征，使其列为空。</p>
</div>
<div class="section" id="id13">
<h3>7.3.4. 链接<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="../developers/performance.html">scikit-learn developer performance documentation</a></li>
<li><a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/sparse.html">Scipy sparse matrix formats documentation</a></li>
</ul>
</div></blockquote>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>

      <!-- 评论留言区代码 start -->
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNDAwMi8xMDU0MA==">
        <script type="text/javascript">
        (function(d, s) {
            var j, e = d.getElementsByTagName(s)[0];

            if (typeof LivereTower === 'function') { return; }

            j = d.createElement(s);
            j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
            j.async = true;

            e.parentNode.insertBefore(j, e);
        })(document, 'script');
        </script>
      </div>
      <!-- 评论留言区代码 end -->

    </div>

    <!-- 提 PR 时按原来文档的字母排序 -->

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <!-- modules/computational_performance.html -->
    <div class="apachecn_doc_right">
      校验者: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/apachecn/scikit-learn-doc-zh">@曲晓峰</a><br/>
                 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/apachecn/scikit-learn-doc-zh">@小瑶</a><br/>
      翻译者: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/apachecn/scikit-learn-doc-zh">@小瑶</a><br/>    
    </div>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

  </div>

  <div class="footer">
      &copy; 2007 - 2017, scikit-learn developers (BSD License).
    <a href="../_sources/modules/computational_performance.rst.txt" rel="nofollow">Show this page source</a>
  </div>
   <div class="rel">
  
  <div class="buttonPrevious">
    <a href="scaling_strategies.html">Previous
    </a>
  </div>
  <div class="buttonNext">
    <a href="../auto_examples/index.html">Next
    </a>
  </div>
  
   </div>

  <!-- google analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  
    ga('create', 'UA-102475051-5', 'auto');
    ga('send', 'pageview');
  
  </script>
  
  <!-- baidu tongji -->
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?9cbab13b4d28a9811ae1d2d2176dab66";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>

  <!-- baidu push -->
  <script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script>
  </body>
</html>